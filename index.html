<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.isroots.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录一些自己的见闻">
<meta property="og:type" content="website">
<meta property="og:title" content="吴晓宁blog">
<meta property="og:url" content="https://blog.isroots.com/index.html">
<meta property="og:site_name" content="吴晓宁blog">
<meta property="og:description" content="记录一些自己的见闻">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="吴晓宁">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.isroots.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>吴晓宁blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">吴晓宁blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">吴晓宁blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/2024/07/22/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-22 14:40:31" itemprop="dateCreated datePublished" datetime="2024-07-22T14:40:31+08:00">2024-07-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="适配器模式-adapter"><a href="#适配器模式-adapter" class="headerlink" title="适配器模式(adapter)"></a>适配器模式(adapter)</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h2><ul>
<li><p><a href="#%E5%AE%9A%E4%B9%89">定义</a></p>
<ul>
<li><p><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F">适配器调用顺序</a></p>
</li>
<li><p><a href="#%E8%A7%A3%E6%9E%84%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">解构适配器模式</a></p>
</li>
</ul>
</li>
<li><p><a href="#%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0">适配器的实现</a></p>
</li>
<li><p><a href="#%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8">类适配器</a></p>
</li>
<li><p><a href="#%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8">对象适配器</a></p>
</li>
<li><p><a href="#%E4%BD%95%E6%97%B6%E9%80%89%E7%94%A8%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">何时选用适配器模式</a></p>
</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>将一个类的接口转化成客户希望的另一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p>
<p>适配器模式的主要功能是进行转化匹配，目的是复用已有的功能，而不是来实现新的接口。也就是说客户端需要的功能是已经实现的，不需要适配器来实现，适配器模式的主要功能是把不兼容的接口转化成客户端期望的样子就可以了，适配器中也可以实现功能，称这种适配器为智能适配器模式</p>
<h4 id="适配器调用顺序"><a href="#适配器调用顺序" class="headerlink" title="适配器调用顺序"></a>适配器调用顺序</h4><p><img src="https://isrootblog-1251140236.cos.ap-beijing.myqcloud.com/uPic/image_xPhwP28EC4.png"></p>
<h4 id="解构适配器模式"><a href="#解构适配器模式" class="headerlink" title="解构适配器模式"></a>解构适配器模式</h4><p>适配器的的主要功能是进行转化匹配，目的是复用已有的功能。而不是来实现新的接口。适配器模式的本质是：转化匹配，复用功能</p>
<h3 id="适配器的实现"><a href="#适配器的实现" class="headerlink" title="适配器的实现"></a><strong>适配器的实现</strong></h3><p>在实现适配器的时候，适配器通常是一个类，一般会让适配器类去实现Target接口，然后在适配器的具体实现里面调用Adaptee，适配器通常是一个Target类型。</p>
<h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a><strong>类适配器</strong></h3><p>适配器模式结构图</p>
<p><img src="https://isrootblog-1251140236.cos.ap-beijing.myqcloud.com/uPic/image_k2YqNJ73kS.png"></p>
<p>采用多重继承对一个接口与另一个接口进行匹配</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The Target defines the domain-specific interface used by the client code.</span><br><span class="line"> */</span><br><span class="line">class Target &#123;</span><br><span class="line"> public:</span><br><span class="line">  virtual ~Target() = default;</span><br><span class="line">  # 要实现的目标接口</span><br><span class="line">  virtual std::string Request() const &#123;</span><br><span class="line">    return &quot;Target: The default target&#x27;s behavior.&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * The Adaptee contains some useful behavior, but its interface is incompatible</span><br><span class="line"> * with the existing client code. The Adaptee needs some adaptation before the</span><br><span class="line"> * client code can use it.</span><br><span class="line"> */</span><br><span class="line">class Adaptee &#123;</span><br><span class="line"> public:</span><br><span class="line"> # 不兼容的接口</span><br><span class="line">  std::string SpecificRequest() const &#123;</span><br><span class="line">    return &quot;.eetpadA eht fo roivaheb laicepS&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * The Adapter makes the Adaptee&#x27;s interface compatible with the Target&#x27;s</span><br><span class="line"> * interface using multiple inheritance.</span><br><span class="line"> */</span><br><span class="line">class Adapter : public Target, public Adaptee &#123;</span><br><span class="line"> public:</span><br><span class="line">  Adapter() &#123;&#125;</span><br><span class="line">  # 在适配器中兼容不兼容的接口</span><br><span class="line">  std::string Request() const override &#123;</span><br><span class="line">    std::string to_reverse = SpecificRequest();</span><br><span class="line">    std::reverse(to_reverse.begin(), to_reverse.end());</span><br><span class="line">    return &quot;Adapter: (TRANSLATED) &quot; + to_reverse;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * The client code supports all classes that follow the Target interface.</span><br><span class="line"> */</span><br><span class="line">void ClientCode(const Target *target) &#123;</span><br><span class="line">  std::cout &lt;&lt; target-&gt;Request();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">int main() &#123;</span><br><span class="line">  std::cout &lt;&lt; &quot;Client: I can work just fine with the Target objects:\n&quot;;</span><br><span class="line">  Target *target = new Target;</span><br><span class="line">  ClientCode(target);</span><br><span class="line">  std::cout &lt;&lt; &quot;\n\n&quot;;</span><br><span class="line">  Adaptee *adaptee = new Adaptee;</span><br><span class="line">  std::cout &lt;&lt; &quot;Client: The Adaptee class has a weird interface. See, I don&#x27;t understand it:\n&quot;;</span><br><span class="line">  std::cout &lt;&lt; &quot;Adaptee: &quot; &lt;&lt; adaptee-&gt;SpecificRequest();</span><br><span class="line">  std::cout &lt;&lt; &quot;\n\n&quot;;</span><br><span class="line">  std::cout &lt;&lt; &quot;Client: But I can work with it via the Adapter:\n&quot;;</span><br><span class="line">  Adapter *adapter = new Adapter;</span><br><span class="line">  ClientCode(adapter);</span><br><span class="line">  std::cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line">​</span><br><span class="line">  delete target;</span><br><span class="line">  delete adaptee;</span><br><span class="line">  delete adapter;</span><br><span class="line">​</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a><strong>对象适配器</strong></h3><ul>
<li><p>适配器模式结构图</p>
<p>  <img src="https://isrootblog-1251140236.cos.ap-beijing.myqcloud.com/uPic/image_H5AnJF6_iF.png"></p>
<p>  对象适配器依赖于对象组合。</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The Target defines the domain-specific interface used by the client code.</span><br><span class="line"> */</span><br><span class="line">class Target &#123;</span><br><span class="line"> public:</span><br><span class="line">  virtual ~Target() = default;</span><br><span class="line">​</span><br><span class="line">  virtual std::string Request() const &#123;</span><br><span class="line">    return &quot;Target: The default target&#x27;s behavior.&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * The Adaptee contains some useful behavior, but its interface is incompatible</span><br><span class="line"> * with the existing client code. The Adaptee needs some adaptation before the</span><br><span class="line"> * client code can use it.</span><br><span class="line"> */</span><br><span class="line">class Adaptee &#123;</span><br><span class="line"> public:</span><br><span class="line">  std::string SpecificRequest() const &#123;</span><br><span class="line">    return &quot;.eetpadA eht fo roivaheb laicepS&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * The Adapter makes the Adaptee&#x27;s interface compatible with the Target&#x27;s</span><br><span class="line"> * interface.</span><br><span class="line"> */</span><br><span class="line">class Adapter : public Target &#123;</span><br><span class="line"> private:</span><br><span class="line">  Adaptee *adaptee_;</span><br><span class="line">​</span><br><span class="line"> public:</span><br><span class="line">  Adapter(Adaptee *adaptee) : adaptee_(adaptee) &#123;&#125;</span><br><span class="line">  std::string Request() const override &#123;</span><br><span class="line">    std::string to_reverse = this-&gt;adaptee_-&gt;SpecificRequest();</span><br><span class="line">    std::reverse(to_reverse.begin(), to_reverse.end());</span><br><span class="line">    return &quot;Adapter: (TRANSLATED) &quot; + to_reverse;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * The client code supports all classes that follow the Target interface.</span><br><span class="line"> */</span><br><span class="line">void ClientCode(const Target *target) &#123;</span><br><span class="line">  std::cout &lt;&lt; target-&gt;Request();</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">int main() &#123;</span><br><span class="line">  std::cout &lt;&lt; &quot;Client: I can work just fine with the Target objects:\n&quot;;</span><br><span class="line">  Target *target = new Target;</span><br><span class="line">  ClientCode(target);</span><br><span class="line">  std::cout &lt;&lt; &quot;\n\n&quot;;</span><br><span class="line">  Adaptee *adaptee = new Adaptee;</span><br><span class="line">  std::cout &lt;&lt; &quot;Client: The Adaptee class has a weird interface. See, I don&#x27;t understand it:\n&quot;;</span><br><span class="line">  std::cout &lt;&lt; &quot;Adaptee: &quot; &lt;&lt; adaptee-&gt;SpecificRequest();</span><br><span class="line">  std::cout &lt;&lt; &quot;\n\n&quot;;</span><br><span class="line">  std::cout &lt;&lt; &quot;Client: But I can work with it via the Adapter:\n&quot;;</span><br><span class="line">  Adapter *adapter = new Adapter(adaptee);</span><br><span class="line">  ClientCode(adapter);</span><br><span class="line">  std::cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line">​</span><br><span class="line">  delete target;</span><br><span class="line">  delete adaptee;</span><br><span class="line">  delete adapter;</span><br><span class="line">​</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="何时选用适配器模式"><a href="#何时选用适配器模式" class="headerlink" title="何时选用适配器模式"></a><strong>何时选用适配器模式</strong></h3><ul>
<li><p>如果想使用一个已经存在的类，但它的接口不符合你的需求，这种情况可以使用适配器模式，来把已有的实现转化成适用你的接口</p>
</li>
<li><p>如果你想创建一个可以复用的类，这个类可能和一些不兼容的类一起工作，这种时候可以使用适配器模式，到时候需要什么就适配什么</p>
</li>
<li><p>如果你想使用一个已经存在的类，但是不可能对每一个类都进行适配，这种情况可以选择对象适配器，直接适配这些子类的父类就可以</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/2024/07/22/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-22 14:40:31" itemprop="dateCreated datePublished" datetime="2024-07-22T14:40:31+08:00">2024-07-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="生成器模式-Builder"><a href="#生成器模式-Builder" class="headerlink" title="生成器模式(Builder)"></a>生成器模式(Builder)</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h2><ul>
<li><p><a href="#%E5%AE%9A%E4%B9%89">定义</a></p>
</li>
<li><p><a href="#%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%8A%9F%E8%83%BD">生成器模式功能</a></p>
</li>
<li><p><a href="#%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F">生成器模式调用顺序</a></p>
</li>
<li><p><a href="#%E8%A7%A3%E6%9E%84%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F">解构生成器模式</a></p>
</li>
<li><p><a href="#%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%E9%87%8D%E8%A6%81%E7%9A%84%E6%9E%84%E6%88%90">生成器模式重要的构成</a></p>
</li>
<li><p><a href="#%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE">生成器模式结构图</a></p>
</li>
<li><p><a href="#%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0">生成器模式的实现</a></p>
</li>
<li><p><a href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81">示例代码</a></p>
</li>
<li><p><a href="#%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">生成器模式的优缺点</a></p>
</li>
<li><p><a href="#%E4%BD%95%E6%97%B6%E9%80%89%E7%94%A8%E5%B7%A5%E7%A8%8B%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">何时选用工程方法模式</a></p>
</li>
<li><p><a href="#%E5%85%B7%E4%BD%93%E7%9A%84%E5%AE%9E%E7%8E%B0">具体的实现</a></p>
</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<h3 id="生成器模式功能"><a href="#生成器模式功能" class="headerlink" title="生成器模式功能"></a><strong>生成器模式功能</strong></h3><p>生成器模式的主要功能是构建复杂的产品，而且是细化的，分步骤的构建产品。也就是生成器模式重在一步一步解决构造复杂对象的问题。更为重要的是，这个构建的过程是统一的，固定不变得，变化的部分放到生成器部分了，只要配置不同的生成器，那么同样的构建过程，就能构建出不同的产品来。</p>
<p>生成器模式的重心在于分离建构算法和具体的构造实现，从而使得构建算法可以重用。</p>
<h3 id="生成器模式调用顺序"><a href="#生成器模式调用顺序" class="headerlink" title="生成器模式调用顺序"></a><strong>生成器模式调用顺序</strong></h3><p><img src="https://isrootblog-1251140236.cos.ap-beijing.myqcloud.com/uPic/image_D4bbQgGmFw.png"></p>
<h3 id="解构生成器模式"><a href="#解构生成器模式" class="headerlink" title="解构生成器模式"></a><strong>解构生成器模式</strong></h3><p>生成器模式的本质：分离整体构建算法和部件构造。</p>
<p>构建一个复杂的对象，本来就有构建的过程，以及构建过程中具体的实现，生成器模式就是用来分离这两个部分，从而使得程序结构更松散，扩展更容易，复杂性更好。</p>
<p>生成器模式的重心在于分离构建算法和具体的构造实现，从而使得构建算法可以重用。具体的构造实现可以很方便的扩展和切换，从而可以灵活的组合来构造出不同的产品对象</p>
<h3 id="生成器模式重要的构成"><a href="#生成器模式重要的构成" class="headerlink" title="生成器模式重要的构成"></a><strong>生成器模式重要的构成</strong></h3><ul>
<li><p>一个部分是Builder接口，这里是定义了如何构建各个部件，也就是知道每个部件的功能是如何实现，以及如何装配这些部件到产品中取</p>
</li>
<li><p>另外一个部分是Director，Director是知道如何组合来构建产品，也就是说Director负责整体的构建算法，而且通常是分步骤地来执行</p>
</li>
</ul>
<h3 id="生成器模式结构图"><a href="#生成器模式结构图" class="headerlink" title="生成器模式结构图"></a><strong>生成器模式结构图</strong></h3><p><img src="https://isrootblog-1251140236.cos.ap-beijing.myqcloud.com/uPic/image_b8HTIiJ8_A.png"></p>
<ul>
<li><p>Builder: 生成器接口，定义创建一个Product对象所需的各个部件的操作。</p>
</li>
<li><p>ConcreteBuilder:具体的生成器实现，实现各个部件的创建，并负责组装Product对象的各个部件，同时还提供一个让用户获取组装完成后的产品对象的方法。</p>
</li>
<li><p>Director：指导者，也被称为导向者，主要用来使用Builder接口，以一个统一的过程来构建所需要的Product对象。</p>
</li>
<li><p>Product: 产品，表示被生成器构建的负责对象，包含多个部件。</p>
</li>
</ul>
<h3 id="生成器模式的实现"><a href="#生成器模式的实现" class="headerlink" title="生成器模式的实现"></a><strong>生成器模式的实现</strong></h3><p>先把构建过程独立出来，在生成器模式中把它称为指导者，由它来指导装配过程，但是不负责每步具体的实现。光有指导者是不够的，必须要有能具体实现每步的对象，在生成器模式中称这些实现对象为生成器。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">// 生成器接口，定义创建一个产品对象所需的各个部件的操作</span><br><span class="line">class Builder&#123;</span><br><span class="line">// 示意方法，构建某个部件</span><br><span class="line">  public:</span><br><span class="line">    // 以下函数代表具体的构建过程</span><br><span class="line">    virtual void buildPartA()const =0;</span><br><span class="line">    virtual void buildPartB()const =0;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">//具体的生成器实现对象 所有的产品使用相同的步骤</span><br><span class="line">// 一辆汽车可能配备有 GPS 设备、行车电脑和几个座位。不同型号的汽车（</span><br><span class="line">// 运动型轿车、SUV 和敞篷车）可能会安装或启用不同的功能。</span><br><span class="line">class ConcreteBuilder1:public Builder&#123;</span><br><span class="line">  public:</span><br><span class="line">    </span><br><span class="line">    Product* getProduct()&#123;</span><br><span class="line">      return resultProduct;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    void buildPartA()&#123;</span><br><span class="line">      // 构建某个部件的功能处理</span><br><span class="line">      print(&#x27;A&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    void buildPartB()&#123;</span><br><span class="line">      // 构建某个部件的功能处理</span><br><span class="line">      print(&#x27;B&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">   private:</span><br><span class="line">     //生成器最终构建的产品对象</span><br><span class="line">     Product* resultProduct;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// 生成器与其他创建型模式的不同之处在于：它让你能创建不遵循相同接口的产品。</span><br><span class="line">// 比如这个是汽车手册</span><br><span class="line">class ConcreteBuilder2:public Builder&#123;</span><br><span class="line">  public:</span><br><span class="line">    </span><br><span class="line">    Product* getProduct()&#123;</span><br><span class="line">      return resultProduct;</span><br><span class="line">    &#125;</span><br><span class="line">    void buildPartA()&#123;</span><br><span class="line">      // 构建某个部件的功能处理</span><br><span class="line">      print(&#x27;A1&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void buildPartB()&#123;</span><br><span class="line">      // 构建某个部件的功能处理</span><br><span class="line">      print(&#x27;B1&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">   private:</span><br><span class="line">     //生成器最终构建的产品对象</span><br><span class="line">     Product* resultProduct;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// 被构建的产品对象接口 </span><br><span class="line">class Product&#123;</span><br><span class="line">  public:</span><br><span class="line">    virtual createProduct()const=0;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// 比如这是构建房子过程中的房顶</span><br><span class="line">class Product1:public Product&#123;</span><br><span class="line">  public:</span><br><span class="line">    void createProduct()&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// 比如这是构建房子过程的墙壁</span><br><span class="line">class Product2:public Product&#123;</span><br><span class="line">  public:</span><br><span class="line">    void createProduct()&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// 指导者，指导使用生成器的接口来构建产品对象</span><br><span class="line">class Director&#123;</span><br><span class="line">  public:</span><br><span class="line">    Director(Builder* builder)&#123;</span><br><span class="line">      this-&gt;builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void construct()&#123;</span><br><span class="line">      builder-&gt;buildPartA()</span><br><span class="line">      builder-&gt;buildPartB()</span><br><span class="line">    &#125;</span><br><span class="line">    void construct1()&#123;</span><br><span class="line">      builder-&gt;buildPartB()</span><br><span class="line">      builder-&gt;buildPartA()</span><br><span class="line">    &#125;</span><br><span class="line">  private:</span><br><span class="line">    Builder* builder;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">int main()&#123;</span><br><span class="line">  ConcreteBuilder1* concreteBuilder = new ConcreteBuilder1();</span><br><span class="line">  Director* director = new Director(concreteBuilder);</span><br><span class="line">  director-&gt;construct();</span><br><span class="line">  // 获取最终创建好的产品</span><br><span class="line">  concreteBuilder-&gt;getProduct()</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成器模式的优缺点"><a href="#生成器模式的优缺点" class="headerlink" title="生成器模式的优缺点"></a><strong>生成器模式的优缺点</strong></h3><ul>
<li><p>优点</p>
<ul>
<li><p>分离接口和实现</p>
<p>  客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已，也就是说，客户端从具体的产品实现中解耦</p>
</li>
<li><p>使得切换产品族变得容易</p>
<p>  因为一个具体的工厂实现代表的是一个产品族。客户端选用不同的工厂实现，就相当于是在切换不同的产品族</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>在使用抽象工厂模式的时候，如果需要选择的层次过多，那么会造成整个类层次变得复杂。</li>
</ul>
</li>
</ul>
<h3 id="何时选用工程方法模式"><a href="#何时选用工程方法模式" class="headerlink" title="何时选用工程方法模式"></a><strong>何时选用工程方法模式</strong></h3><ul>
<li><p>如果创建对象的算法，应该独立于该对象的组成部分以及他们的装配方式时</p>
</li>
<li><p>如果同一个构建过程有着不同的表示时</p>
</li>
</ul>
<h3 id="具体的实现"><a href="#具体的实现" class="headerlink" title="具体的实现"></a><strong>具体的实现</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * It makes sense to use the Builder pattern only when your products are quite</span><br><span class="line"> * complex and require extensive configuration.</span><br><span class="line"> *</span><br><span class="line"> * Unlike in other creational patterns, different concrete builders can produce</span><br><span class="line"> * unrelated products. In other words, results of various builders may not</span><br><span class="line"> * always follow the same interface.</span><br><span class="line"> */</span><br><span class="line">​</span><br><span class="line">class Product1&#123;</span><br><span class="line">    public:</span><br><span class="line">    std::vector&lt;std::string&gt; parts_;</span><br><span class="line">    void ListParts()const&#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Product parts: &quot;;</span><br><span class="line">        for (size_t i=0;i&lt;parts_.size();i++)&#123;</span><br><span class="line">            if(parts_[i]== parts_.back())&#123;</span><br><span class="line">                std::cout &lt;&lt; parts_[i];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                std::cout &lt;&lt; parts_[i] &lt;&lt; &quot;, &quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; &quot;\n\n&quot;; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * The Builder interface specifies methods for creating the different parts of</span><br><span class="line"> * the Product objects.</span><br><span class="line"> * 创建者接口 指定了为不同的对象创建不同的部件的方法</span><br><span class="line"> */</span><br><span class="line">class Builder&#123;</span><br><span class="line">    public:</span><br><span class="line">    virtual ~Builder()&#123;&#125;</span><br><span class="line">    virtual void ProducePartA() const =0;</span><br><span class="line">    virtual void ProducePartB() const =0;</span><br><span class="line">    virtual void ProducePartC() const =0;</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line"> * The Concrete Builder classes follow the Builder interface and provide</span><br><span class="line"> * specific implementations of the building steps. Your program may have several</span><br><span class="line"> * variations of Builders, implemented differently.</span><br><span class="line"> */</span><br><span class="line">class ConcreteBuilder1 : public Builder&#123;</span><br><span class="line">    private:</span><br><span class="line">​</span><br><span class="line">    Product1* product;</span><br><span class="line">​</span><br><span class="line">    /**</span><br><span class="line">     * A fresh builder instance should contain a blank product object, which is</span><br><span class="line">     * used in further assembly.</span><br><span class="line">     */</span><br><span class="line">    public:</span><br><span class="line">​</span><br><span class="line">    ConcreteBuilder1()&#123;</span><br><span class="line">        this-&gt;Reset();</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    ~ConcreteBuilder1()&#123;</span><br><span class="line">        delete product;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    void Reset()&#123;</span><br><span class="line">        this-&gt;product= new Product1();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * All production steps work with the same product instance.</span><br><span class="line">     */</span><br><span class="line">​</span><br><span class="line">    void ProducePartA()const override&#123;</span><br><span class="line">        this-&gt;product-&gt;parts_.push_back(&quot;PartA1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    void ProducePartB()const override&#123;</span><br><span class="line">        this-&gt;product-&gt;parts_.push_back(&quot;PartB1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    void ProducePartC()const override&#123;</span><br><span class="line">        this-&gt;product-&gt;parts_.push_back(&quot;PartC1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    Product1* GetProduct() &#123;</span><br><span class="line">        Product1* result= this-&gt;product;</span><br><span class="line">        this-&gt;Reset();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * The Director is only responsible for executing the building steps in a</span><br><span class="line"> * particular sequence. It is helpful when producing products according to a</span><br><span class="line"> * specific order or configuration. Strictly speaking, the Director class is</span><br><span class="line"> * optional, since the client can control builders directly.</span><br><span class="line"> */</span><br><span class="line">class Director&#123;</span><br><span class="line">    /**</span><br><span class="line">     * @var Builder</span><br><span class="line">     */</span><br><span class="line">    private:</span><br><span class="line">    Builder* builder;</span><br><span class="line">    /**</span><br><span class="line">     * The Director works with any builder instance that the client code passes</span><br><span class="line">     * to it. This way, the client code may alter the final type of the newly</span><br><span class="line">     * assembled product.</span><br><span class="line">     */</span><br><span class="line">​</span><br><span class="line">    public:</span><br><span class="line">​</span><br><span class="line">    void set_builder(Builder* builder)&#123;</span><br><span class="line">        this-&gt;builder=builder;</span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    /**</span><br><span class="line">     * The Director can construct several product variations using the same</span><br><span class="line">     * building steps.</span><br><span class="line">     */</span><br><span class="line">​</span><br><span class="line">    void BuildMinimalViableProduct()&#123;</span><br><span class="line">        this-&gt;builder-&gt;ProducePartA();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void BuildFullFeaturedProduct()&#123;</span><br><span class="line">        this-&gt;builder-&gt;ProducePartA();</span><br><span class="line">        this-&gt;builder-&gt;ProducePartB();</span><br><span class="line">        this-&gt;builder-&gt;ProducePartC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line"> * The client code creates a builder object, passes it to the director and then</span><br><span class="line"> * initiates the construction process. The end result is retrieved from the</span><br><span class="line"> * builder object.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * I used raw pointers for simplicity however you may prefer to use smart</span><br><span class="line"> * pointers here</span><br><span class="line"> */</span><br><span class="line">void ClientCode(Director&amp; director)</span><br><span class="line">&#123;</span><br><span class="line">    ConcreteBuilder1* builder = new ConcreteBuilder1();</span><br><span class="line">    director.set_builder(builder);</span><br><span class="line">    std::cout &lt;&lt; &quot;Standard basic product:\n&quot;; </span><br><span class="line">    director.BuildMinimalViableProduct();</span><br><span class="line">    </span><br><span class="line">    Product1* p= builder-&gt;GetProduct();</span><br><span class="line">    p-&gt;ListParts();</span><br><span class="line">    delete p;</span><br><span class="line">​</span><br><span class="line">    std::cout &lt;&lt; &quot;Standard full featured product:\n&quot;; </span><br><span class="line">    director.BuildFullFeaturedProduct();</span><br><span class="line">​</span><br><span class="line">    p= builder-&gt;GetProduct();</span><br><span class="line">    p-&gt;ListParts();</span><br><span class="line">    delete p;</span><br><span class="line">​</span><br><span class="line">    // Remember, the Builder pattern can be used without a Director class.</span><br><span class="line">    std::cout &lt;&lt; &quot;Custom product:\n&quot;;</span><br><span class="line">    builder-&gt;ProducePartA();</span><br><span class="line">    builder-&gt;ProducePartC();</span><br><span class="line">    p=builder-&gt;GetProduct();</span><br><span class="line">    p-&gt;ListParts();</span><br><span class="line">    delete p;</span><br><span class="line">​</span><br><span class="line">    delete builder;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">int main()&#123;</span><br><span class="line">    Director* director= new Director();</span><br><span class="line">    ClientCode(*director);</span><br><span class="line">    delete director;</span><br><span class="line">    return 0;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/2024/07/22/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-22 14:40:31" itemprop="dateCreated datePublished" datetime="2024-07-22T14:40:31+08:00">2024-07-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="抽象工厂方法-Abstract-Factory"><a href="#抽象工厂方法-Abstract-Factory" class="headerlink" title="抽象工厂方法(Abstract Factory)"></a>抽象工厂方法(Abstract Factory)</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h2><ul>
<li><p><a href="#%E5%AE%9A%E4%B9%89">定义</a></p>
</li>
<li><p><a href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F">抽象工厂方法调用顺序</a></p>
</li>
<li><p><a href="#%E8%A7%A3%E6%9E%84%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">解构抽象工厂方法模式</a></p>
</li>
<li><p><a href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%9B%BE">工厂方法结构图</a></p>
</li>
<li><p><a href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0">抽象工厂方法的实现</a></p>
</li>
<li><p><a href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">工厂方法模式的优缺点</a></p>
</li>
<li><p><a href="#%E4%BD%95%E6%97%B6%E9%80%89%E7%94%A8%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">何时选用抽象工厂方法模式</a></p>
</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类</p>
<p>本质</p>
<p>抽象工厂的本质：选择产品簇的实现</p>
<h3 id="抽象工厂方法调用顺序"><a href="#抽象工厂方法调用顺序" class="headerlink" title="抽象工厂方法调用顺序"></a><strong>抽象工厂方法调用顺序</strong></h3><p><img src="https://isrootblog-1251140236.cos.ap-beijing.myqcloud.com/uPic/image_b424Se6z9T.png"></p>
<h3 id="解构抽象工厂方法模式"><a href="#解构抽象工厂方法模式" class="headerlink" title="解构抽象工厂方法模式"></a><strong>解构抽象工厂方法模式</strong></h3><p>工厂方法模式的本质定义一系列产品族的接口，工厂方法选择单个产品的实现，虽然一个类里面可以有多个工厂方法，但是这些方法之间一般是没有联系的。</p>
<p>但是抽象工厂着重的就是为一个产品族选择实现，定义在抽象工厂里面的方法通常是有联系的。</p>
<h3 id="工厂方法结构图"><a href="#工厂方法结构图" class="headerlink" title="工厂方法结构图"></a><strong>工厂方法结构图</strong></h3><p><img src="https://isrootblog-1251140236.cos.ap-beijing.myqcloud.com/uPic/image_6OBXO_9wVH.png"></p>
<ul>
<li><p>Abstract Factory: 抽象工厂，定义创建一系列产品对象的操作接口</p>
</li>
<li><p>Concrete Factory: 具体的工厂，实现抽象工厂定义的方法，具体实现一系列产品对象的创建</p>
</li>
<li><p>Abstract Product：定义一类产品对象的接口</p>
</li>
<li><p>Concrete Product: 具体的产品实现对象，通常在具体工厂里面，会选择具体的产品实现对象，来创建符合抽象工厂定义的方法返回的产品类型的对象</p>
</li>
<li><p>Client: 客户端，主要使用抽象工厂来获取一系列所需要的产品对象。</p>
</li>
</ul>
<h3 id="抽象工厂方法的实现"><a href="#抽象工厂方法的实现" class="headerlink" title="抽象工厂方法的实现"></a><strong>抽象工厂方法的实现</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// 抽象工厂的接口，声明创建抽象产品的操作</span><br><span class="line">class AbstractFactory&#123;</span><br><span class="line">  public:</span><br><span class="line">    virtual ~AbstractFactory();</span><br><span class="line">    virtual AbstractProductA* createProductA()const =0;</span><br><span class="line">   </span><br><span class="line">    virtual AbstractProductB* createProductB()const=0;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class AbstractProductA:&#123;</span><br><span class="line">  // 定义A类产品抽象操作</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class AbstractProductB:&#123;</span><br><span class="line">  // 定义B类产品的抽象操作</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">// 产品A的具体实现</span><br><span class="line">class ProductA1:public AbstractProductA&#123;</span><br><span class="line">  // 实现A 产品中定义的接口</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class ProductA2:public AbstractProductA&#123;</span><br><span class="line">  // 实现A 产品中定义的接口</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class ProductB1:public AbstractProductB&#123;</span><br><span class="line">  // 实现b 产品中定义的接口</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class ProductB2:public AbstractProductB&#123;</span><br><span class="line">  // 实现b 产品中定义的接口</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class ConcreteFactory1 : public AbstractFactory&#123;</span><br><span class="line">  public:</span><br><span class="line">    AbstractProductA* createProductA()&#123;</span><br><span class="line">      return new ProductA1()</span><br><span class="line">    &#125;</span><br><span class="line">    AbstractProductB* createProductB()&#123;</span><br><span class="line">      return new ProductB1()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">class ConcreteFactory2 : public AbstractFactory&#123;</span><br><span class="line">  public:</span><br><span class="line">    AbstractProductA* createProductA()&#123;</span><br><span class="line">      return new ProductA2()</span><br><span class="line">    &#125;</span><br><span class="line">    AbstractProductB* createProductB()&#123;</span><br><span class="line">      return new ProductB2()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">int main()&#123;</span><br><span class="line">  // 创建抽象工厂对象</span><br><span class="line">  AbstractFactory* af = new ConcreFactory1();</span><br><span class="line">  </span><br><span class="line">  // 通过抽象工厂来获取一系列的对象，例如产品A和B</span><br><span class="line">  af-&gt;createProductA()</span><br><span class="line">  af-&gt;createProductB()</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure>

<h3 id="工厂方法模式的优缺点"><a href="#工厂方法模式的优缺点" class="headerlink" title="工厂方法模式的优缺点"></a><strong>工厂方法模式的优缺点</strong></h3><ul>
<li><p>优点</p>
<ul>
<li><p>分离接口和实现</p>
<p>  客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已，也就是说，客户端从具体的产品实现中解耦</p>
</li>
<li><p>使得切换产品族变得容易</p>
<p>  因为一个具体的工厂实现代表的是一个产品族。客户端选用不同的工厂实现，就相当于是在切换不同的产品族</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>不太容易扩展新的产品</p>
<p>  如果需要给整个产品簇添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类，</p>
</li>
<li><p>在使用抽象工厂模式的时候，如果需要选择的层次过多，那么会造成整个类层次变得复杂。</p>
</li>
</ul>
</li>
</ul>
<h3 id="何时选用抽象工厂方法模式"><a href="#何时选用抽象工厂方法模式" class="headerlink" title="何时选用抽象工厂方法模式"></a><strong>何时选用抽象工厂方法模式</strong></h3><p>如果希望一个系统独立于它的产品的创建，组合和表示的时候，换句话说，希望一个系统只是知道产品的接口，而不关心实现的时候</p>
<p>如果一个系统要由多个产品系列中的一个来配置的时候，换句话说，就是可以动态的切换产品族的时候</p>
<p>如果要强调一系列相关产品的接口，以便联合使用他们的时候</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/2024/07/22/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%91%84%E5%83%8F%E5%A4%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%91%84%E5%83%8F%E5%A4%B4/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-22 14:40:31" itemprop="dateCreated datePublished" datetime="2024-07-22T14:40:31+08:00">2024-07-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="树莓派官方摄像头模块-V3-的配置及-libcamera-的使用教程"><a href="#树莓派官方摄像头模块-V3-的配置及-libcamera-的使用教程" class="headerlink" title="树莓派官方摄像头模块 V3 的配置及 libcamera 的使用教程"></a>树莓派官方摄像头模块 V3 的配置及 libcamera 的使用教程</h1><p>树莓派官方<a target="_blank" rel="noopener" href="https://shumeipai.nxez.com/2023/01/18/raspberry-pi-camera-modules-v3-released.html">摄像头模块 Camera Module 3</a> 发布之后，有些朋友使用 libcamera 软件库来拍摄会发现报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0:11:48.500378214] [2153]  INFO Camera camera_manager.cpp:299 libcamera v0.0.4+22-923f5d70</span><br><span class="line">ERROR: *** no cameras available ***</span><br></pre></td></tr></table></figure>

<p>假设你已经在断电状态下正确连接好了摄像头和树莓派主板的 CSI 接口。下面我们介绍在树莓派官方系统 Raspberry Pi OS 下使用 V3 版摄像头（IMX708 传感器）的正确方法。</p>
<p>给树莓派上电进入系统，首先依然需要运行 sudo raspi-config 命令进入系统配置工具，选择 Interfacing Options – Legacy Camera 菜单禁用 Legacy 摄像头。</p>
<p>然后运行下面的命令修改配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /boot/config.txt</span><br></pre></td></tr></table></figure>

<p>找到下面几行配置，修改后面的数值如下。如果某行没有找到，可在文件末尾添加一行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">camera_auto_detect=0</span><br><span class="line">gpu_mem=128</span><br></pre></td></tr></table></figure>

<p>在最后面再加一行，手动配置摄像头传感器型号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dtoverlay=imx708</span><br></pre></td></tr></table></figure>

<p>CTRL+X 后键入 Y 回车保存。</p>
<p>运行下面的命令修改 &#x2F;etc&#x2F;modules 内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/modules</span><br></pre></td></tr></table></figure>

<p>在文件末尾添加一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcm2835-v4l2</span><br></pre></td></tr></table></figure>

<p>同样 CTRL+X 后键入 Y 回车保存。</p>
<p>运行命令 sudo reboot 重启树莓派。</p>
<p>然后就可以使用 libcamera 工具中的命令来拍摄了。</p>
<p>libcamera-hello 命令相当于相机的 “hello world” 应用程序。它启动相机，显示预览窗口，而不执行任何其他操作。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libcamera-hello</span><br></pre></td></tr></table></figure>

<p>应显示预览窗口约 5 秒钟。-t 选项允许用户选择窗口的显示时间长度，其中 以毫秒为单位。若要无限期运行预览，请使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libcamera-hello -t 0</span><br></pre></td></tr></table></figure>

<p>可以通过单击窗口的关闭按钮或在终端中使用 Ctrl-C 来停止预览。</p>
<h4 id="libcamera-jpeg"><a href="#libcamera-jpeg" class="headerlink" title="libcamera-jpeg"></a>libcamera-jpeg</h4><p>libcamera-jpeg 命令是一个简单的静止图像捕获应用程序。它故意避免了 libcamera-still 的一些附加功能，它试图更充分地模仿 raspistill。因此，代码明显更容易理解，并且在实践中仍然提供许多相同的功能。</p>
<p>要捕获全分辨率 JPEG 图像，请使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libcamera-jpeg -o test.jpg</span><br></pre></td></tr></table></figure>

<p>这将显示大约 5 秒的预览，然后捕获全分辨率 JPEG 图像到文件 test.jpg。</p>
<p>-t 选项 可用于更改预览显示的时间长度，而 –width 和 –height 选项将更改捕获的静止图像的分辨率。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libcamera-jpeg -o test.jpg -t 2000 --width 640 --height 480</span><br></pre></td></tr></table></figure>

<p>将捕获 VGA 大小的图像。</p>
<h4 id="libcamera-still"><a href="#libcamera-still" class="headerlink" title="libcamera-still"></a>libcamera-still</h4><p>libcamera-still 与 libcamera-jpeg 非常相似，但支持更多的 raspistill 选项。和以前一样，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libcamera-still -o test.jpg</span><br></pre></td></tr></table></figure>

<p><strong>编码</strong> libcamera-still 允许以多种不同的格式保存文件。它支持 png 和 bmp 编码。它还允许将文件另存为 RGB 或 YUV 像素的二进制转储，完全没有编码或文件格式。在后一种情况下，读取文件的应用程序必须自行了解像素排列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">libcamera-still -e png -o test.png</span><br><span class="line">libcamera-still -e bmp -o test.bmp</span><br><span class="line">libcamera-still -e rgb -o test.data</span><br><span class="line">libcamera-still -e yuv420 -o test.data</span><br></pre></td></tr></table></figure>

<p>请注意，保存图像的格式取决于 -e（等效的 –encoding）选项，并且不会根据输出文件名自动选择。</p>
<h4 id="原始图像（Raw）捕获"><a href="#原始图像（Raw）捕获" class="headerlink" title="原始图像（Raw）捕获"></a>原始图像（Raw）捕获</h4><p>原始图像是由图像传感器直接生成的图像，在ISP（图像信号处理器）或任何 CPU 内核对其应用任何处理之前。对于彩色图像传感器，这些通常是拜耳格式的图像。请注意，原始图像与我们之前看到的已处理但未编码的 RGB 或 YUV 图像有很大不同。</p>
<p>捕获原始图像使用下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libcamera-still -r -o test.jpg</span><br></pre></td></tr></table></figure>

<p>在这里，-r 选项（也称为 –raw）表示捕获原始图像以及 JPEG。实际上，原始图像是生成JPEG的确切图像。原始图像以 DNG（Adobe Digital Negative）格式保存，并与许多标准应用程序兼容，例如 dcraw 或 RawTherapee。原始图像将保存到具有相同名称但扩展名为 .dng 的文件中，因此在本例中为 test.dng。</p>
<h4 id="libcamera-vid"><a href="#libcamera-vid" class="headerlink" title="libcamera-vid"></a>libcamera-vid</h4><p>Libcamera-vid 是视频捕获应用程序。默认情况下，它使用树莓派的硬件 H.264 编码器。它将显示一个预览窗口，并将编码的比特流写入指定的输出。例如，要将 10 秒的视频写入文件，请使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libcamera-vid -t 10000 -o test.h264</span><br></pre></td></tr></table></figure>

<p>生成的文件可以使用 vlc 播放（以及其他应用程序）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vlc test.h264</span><br></pre></td></tr></table></figure>

<p>请注意，这是一个未打包的视频比特流，它没有包装在任何类型的容器格式（例如 mp4 文件）中。–save-pts 选项可用于输出帧时间戳，以便随后可以使用 mkvmerge 等工具将比特流转换为适当的格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libcamera-vid -o test.h264 --save-pts timestamps.txt</span><br></pre></td></tr></table></figure>

<p>然后，如果你想要一个 MKV 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkvmerge -o test.mkv --timecodes 0:timestamps.txt test.h264</span><br></pre></td></tr></table></figure>

<p>有关 libcamera 的更多使用方法可以参考<a target="_blank" rel="noopener" href="https://www.raspberrypi.com/documentation/computers/camera_software.html#libcamera-and-libcamera-apps">官方文档</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/2024/07/22/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-22 14:40:31" itemprop="dateCreated datePublished" datetime="2024-07-22T14:40:31+08:00">2024-07-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="工厂方法-Factory"><a href="#工厂方法-Factory" class="headerlink" title="工厂方法(Factory)"></a>工厂方法(Factory)</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h2><ul>
<li><p><a href="#%E5%AE%9A%E4%B9%89">定义</a></p>
</li>
<li><p><a href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F">工厂方法调用顺序</a></p>
</li>
<li><p><a href="#%E8%A7%A3%E6%9E%84%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">解构工厂方法模式</a></p>
</li>
<li><p><a href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%9B%BE">工厂方法结构图</a></p>
</li>
<li><p><a href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0">工厂方法的实现</a></p>
</li>
<li><p><a href="#%E8%B0%81%E6%9D%A5%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1">谁来使用工厂方法创建对象</a></p>
</li>
<li><p><a href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">工厂方法模式的优缺点</a></p>
</li>
<li><p><a href="#%E4%BD%95%E6%97%B6%E9%80%89%E7%94%A8%E5%B7%A5%E7%A8%8B%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F">何时选用工程方法模式</a></p>
</li>
<li><p><a href="#code">code</a></p>
</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factiry Methos 使一个类的实例化延迟到其子类</p>
<h3 id="工厂方法调用顺序"><a href="#工厂方法调用顺序" class="headerlink" title="工厂方法调用顺序"></a><strong>工厂方法调用顺序</strong></h3><p><img src="https://isrootblog-1251140236.cos.ap-beijing.myqcloud.com/uPic/image_os9Z3Pj932.png"></p>
<h3 id="解构工厂方法模式"><a href="#解构工厂方法模式" class="headerlink" title="解构工厂方法模式"></a><strong>解构工厂方法模式</strong></h3><p>工厂方法模式的本质是延迟到子类来选择实现。工厂方法模式很好的提现了”依赖倒置原则”，依赖倒置原则告诉我们，<strong>要依赖抽象，不要依赖于具体的类</strong>，简单点说就是不能让高层组件依赖于底层组件，而且不管高层组件还是底层组件，都应该依赖于抽象。</p>
<h3 id="工厂方法结构图"><a href="#工厂方法结构图" class="headerlink" title="工厂方法结构图"></a><strong>工厂方法结构图</strong></h3><p><img src="https://isrootblog-1251140236.cos.ap-beijing.myqcloud.com/uPic/image_iOs06-LoSA.png"></p>
<h3 id="工厂方法的实现"><a href="#工厂方法的实现" class="headerlink" title="工厂方法的实现"></a><strong>工厂方法的实现</strong></h3><p>在工厂方法模式里面，客户端要么使用Creator对象，要么使用Creator创建的对象，一般客户端不直接使用工厂方法。</p>
<ul>
<li><p>让所有产品都遵循同一接口，该接口必须声明对所有产品有意义的方法</p>
</li>
<li><p>在创建类中添加一个空的工厂方法，该方法的返回类型必须遵循通用的产品接口</p>
</li>
<li><p>在创建者代码中找到对于产品构造函数的所有引用，将他们依次替换为对于工厂方法的调用，同时将创建产品的代码移入到工厂方法。</p>
</li>
<li><p>为工厂中的每种产品编写一个创建者子类，然后再子类中重写工厂方法，并将基本方法中的相关创建代码移动到工厂方法中。</p>
</li>
<li><p>如果应用中产品类型太多，那么为每个产品创建子类并无太大的必要，这时你也可以在子类中复用基类中的控制参数</p>
<p>  例如， 设想你有以下一些层次结构的类。 基类 <code>邮件</code>及其子类 <code>航空邮件</code>和 <code>陆路邮件</code> ； ​ <code>运输</code>及其子类 <code>飞机</code>, <code>卡车</code>和 <code>火车</code> 。 ​ <code>航空邮件</code>仅使用 <code>飞机</code>对象， 而 <code>陆路邮件</code>则会同时使用 <code>卡车</code>和 <code>火车</code>对象。 你可以编写一个新的子类 （例如 <code>火车邮件</code> ） 来处理这两种情况， 但是还有其他可选的方案。 客户端代码可以给 <code>陆路邮件</code>类传递一个参数， 用于控制其希望获得的产品。</p>
</li>
<li><p>如果代码经过上述移动后，基础工厂中已经没有任何代码，你可以将其转变为抽象类。</p>
</li>
</ul>
<h3 id="谁来使用工厂方法创建对象"><a href="#谁来使用工厂方法创建对象" class="headerlink" title="谁来使用工厂方法创建对象"></a><strong>谁来使用工厂方法创建对象</strong></h3><p>在工厂方法模式里面，应该是Creator中的其他方法在使用工厂方法创建的对象，虽然也可以把工厂方法创建的对象直接提供给Creator外部使用，但工厂方法模式的本意是有Creator对象内部的方法来使用工厂方法创建的对象，也就是说，工厂方法一般不提供给Creator外部使用</p>
<p>客户端应该使用Creator对象，或者使用由Creator创建出来的对象，对于客户端使用Creator对象，这个时候工厂方法创建的对象，是由Creator中的某些方法使用，对于使用那些由Creator创建出来的对象，这个时候工厂方法创建的对象，是构成客户端需要的对象一部分。</p>
<h3 id="工厂方法模式的优缺点"><a href="#工厂方法模式的优缺点" class="headerlink" title="工厂方法模式的优缺点"></a><strong>工厂方法模式的优缺点</strong></h3><ul>
<li><p>可以在不知具体实现的情况下编程</p>
<p>  工厂方法模式可以让你在实现功能的时候，如果需要某个产品对象，只需要使用产品接口即可。而无需关心具体的实现，具体实现的任务延迟到子类去完成。</p>
</li>
<li><p>方便新的功能接口扩展</p>
</li>
</ul>
<h3 id="何时选用工程方法模式"><a href="#何时选用工程方法模式" class="headerlink" title="何时选用工程方法模式"></a><strong>何时选用工程方法模式</strong></h3><p>如果一类需要创建某个接口的对象，但是又不知道具体的实现，这种情况可以选用工厂方法模式，把创建对象的工作延迟到子类中去实现</p>
<p>如果一个类本身就希望由它的子类来创建所需的对象时候，应该使用工厂方法模式</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a><strong>code</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The Product interface declares the operations that all concrete products must</span><br><span class="line"> * implement. product 接口声明了所有具体产品必须实现的接口</span><br><span class="line"> */</span><br><span class="line"> class Product&#123;</span><br><span class="line">   public:</span><br><span class="line">   // 可以定义product的属性和方法</span><br><span class="line">    virtual ~Product()&#123;&#125;;</span><br><span class="line">    virtual std::string Operator() const = 0;</span><br><span class="line"> &#125;</span><br><span class="line">/**</span><br><span class="line"> * Concrete Products provide various implementations of the Product interface.</span><br><span class="line"> 具体的产品提供了多样实现产品的接口</span><br><span class="line"> */ </span><br><span class="line"> class ConcreteProduct1:public Product&#123;</span><br><span class="line">   // 具体的procduct</span><br><span class="line">   public:</span><br><span class="line">    std::string Operation() const override&#123;</span><br><span class="line">      return &quot;&#123;Result of the ConcreteProduct1&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> class ConcreteProduct2:public Product&#123;</span><br><span class="line">   public:</span><br><span class="line">    std::string Operation() const override&#123;</span><br><span class="line">      return &quot;&#123;Result of the ConcreteProduct2&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> /**</span><br><span class="line"> * The Creator class declares the factory method that is supposed to return an</span><br><span class="line"> * object of a Product class. The Creator&#x27;s subclasses usually provide the</span><br><span class="line"> * implementation of this method.</span><br><span class="line"> */</span><br><span class="line"> class Creator&#123;</span><br><span class="line">   /**</span><br><span class="line">   * Note that the Creator may also provide some default implementation of the</span><br><span class="line">   * factory method.</span><br><span class="line">   */</span><br><span class="line">   // 创建器，声明工厂方法</span><br><span class="line">   public:</span><br><span class="line">     virtual ~Creator()&#123;&#125;;</span><br><span class="line">     // 创建创建生产者的接口</span><br><span class="line">     virtual Product* productFactor() const = 0;</span><br><span class="line">   /**</span><br><span class="line">   * Also note that, despite its name, the Creator&#x27;s primary responsibility is</span><br><span class="line">   * not creating products. Usually, it contains some core business logic that</span><br><span class="line">   * relies on Product objects, returned by the factory method. Subclasses can</span><br><span class="line">   * indirectly change that business logic by overriding the factory method and</span><br><span class="line">   * returning a different type of product from it.</span><br><span class="line">   */</span><br><span class="line">   // 示意方法，实现某些具体的功能</span><br><span class="line">   std::string SomeOperation() const &#123;</span><br><span class="line">      Product* product = this-&gt;productFactor();</span><br><span class="line">      std::string result = &quot;Creator: The same creator&#x27;s code has just worked with &quot; + product-&gt;Operation();</span><br><span class="line">   &#125;</span><br><span class="line">      delete product;</span><br><span class="line">      return result;</span><br><span class="line">     </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> // 具体的创建器的实现</span><br><span class="line"> class concreteCreator1:public Creator&#123;</span><br><span class="line">   public:</span><br><span class="line">     Product* productFactory() &#123;</span><br><span class="line">       return new ConcreteProduct1()</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> class concreteCreator2:public Creator&#123;</span><br><span class="line">   public:</span><br><span class="line">    Product* productFactory()&#123;</span><br><span class="line">      return new ConcreteProduct2()</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> void ClientCode(const Creator&amp; creator) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  std::cout &lt;&lt; &quot;Client: I&#x27;m not aware of the creator&#x27;s class, but it still works.\n&quot;</span><br><span class="line">            &lt;&lt; creator.SomeOperation() &lt;&lt; std::endl;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> int main()&#123;</span><br><span class="line">   std::cout &lt;&lt; &quot;App: Launched with the ConcreteCreator1.\n&quot;;</span><br><span class="line">   Creator* creator1 = new ConcreteCreator1()</span><br><span class="line">   clientCode(creator1)</span><br><span class="line">   std::cout &lt;&lt; std::endl;</span><br><span class="line">   std::cout &lt;&lt; &quot;App: Launched with the ConcreteCreator2.\n&quot;;</span><br><span class="line">   Creator* creator2 = new ConcreteCreator2();</span><br><span class="line">   ClientCode(*creator2);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/2024/07/22/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-22 14:40:31" itemprop="dateCreated datePublished" datetime="2024-07-22T14:40:31+08:00">2024-07-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="原型模式-Prototype"><a href="#原型模式-Prototype" class="headerlink" title="原型模式(Prototype)"></a>原型模式(Prototype)</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h2><ul>
<li><p><a href="#%E5%AE%9A%E4%B9%89">定义</a></p>
</li>
<li><p><a href="#%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%B4%E6%98%8E">结构和说明</a></p>
</li>
<li><p><a href="#%E6%B3%A8%E6%84%8F">注意</a></p>
</li>
</ul>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>用原型示例指定创建对象的种类。并通过拷贝这些原型创建新的对象，即重新创建一个拷贝对象的副本，而无需去执行拷贝对象的构造函数</p>
<h3 id="结构和说明"><a href="#结构和说明" class="headerlink" title="结构和说明"></a><strong>结构和说明</strong></h3><p><img src="https://isrootblog-1251140236.cos.ap-beijing.myqcloud.com/uPic/202309121953363.png" alt="image.png"></p>
<ul>
<li><p>Prototype : 声明一个克隆自身的接口，用来约束想要克隆自己的类，要求它们都要实现这里定义的克隆方法</p>
</li>
<li><p>ConcretePrototype: 实现 Prototype 接口的类，这些类真正实现了克隆自身的功能</p>
</li>
<li><p>Client : 使用原型的客户端，首先要获取到原型实例对象，然后通过原型实例克隆自身来创建新的对象实例</p>
</li>
</ul>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h3><h4 id="原型实例和克隆的实例"><a href="#原型实例和克隆的实例" class="headerlink" title="原型实例和克隆的实例"></a>原型实例和克隆的实例</h4><p><strong>原型实例和克隆出来的实例，本质上是不同的实例，克隆完成后，他们之间是没有关联的，如果克隆出来的实例属性值发生了改变，是不会影响到原型实例的</strong></p>
<h4 id="深度克隆和浅度克隆"><a href="#深度克隆和浅度克隆" class="headerlink" title="深度克隆和浅度克隆"></a>深度克隆和浅度克隆</h4><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">using std::string;</span><br><span class="line">// 原型的类型</span><br><span class="line">enum Type &#123;</span><br><span class="line">  PROTOTYPE_1 = 0,</span><br><span class="line">  PROTOTYPE_2</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">// 原型接口类</span><br><span class="line">class Prototype &#123;</span><br><span class="line"> protected:</span><br><span class="line">  string prototype_name_;</span><br><span class="line">  float prototype_field_;</span><br><span class="line">​</span><br><span class="line"> public:</span><br><span class="line">  Prototype() &#123;&#125;</span><br><span class="line">  Prototype(string prototype_name)</span><br><span class="line">      : prototype_name_(prototype_name) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  virtual ~Prototype() &#123;&#125;</span><br><span class="line">  virtual Prototype *Clone() const = 0;</span><br><span class="line">  virtual void Method(float prototype_field) &#123;</span><br><span class="line">    this-&gt;prototype_field_ = prototype_field;</span><br><span class="line">    std::cout &lt;&lt; &quot;Call Method from &quot; &lt;&lt; prototype_name_ &lt;&lt; &quot; with field : &quot; &lt;&lt; prototype_field &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line"># 具体的原型类</span><br><span class="line">class ConcretePrototype1 : public Prototype &#123;</span><br><span class="line"> private:</span><br><span class="line">  float concrete_prototype_field1_;</span><br><span class="line">​</span><br><span class="line"> public:</span><br><span class="line">  ConcretePrototype1(string prototype_name, float concrete_prototype_field)</span><br><span class="line">      : Prototype(prototype_name), concrete_prototype_field1_(concrete_prototype_field) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  # 实现自我复制  这里使用的浅拷贝</span><br><span class="line">  Prototype *Clone() const override &#123;</span><br><span class="line">    return new ConcretePrototype1(*this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">class ConcretePrototype2 : public Prototype &#123;</span><br><span class="line"> private:</span><br><span class="line">  float concrete_prototype_field2_;</span><br><span class="line">​</span><br><span class="line"> public:</span><br><span class="line">  ConcretePrototype2(string prototype_name, float concrete_prototype_field)</span><br><span class="line">      : Prototype(prototype_name), concrete_prototype_field2_(concrete_prototype_field) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  Prototype *Clone() const override &#123;</span><br><span class="line">    return new ConcretePrototype2(*this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">class PrototypeFactory &#123;</span><br><span class="line"> private:</span><br><span class="line">  std::unordered_map&lt;Type, Prototype *, std::hash&lt;int&gt;&gt; prototypes_;</span><br><span class="line">​</span><br><span class="line"> public:</span><br><span class="line">  PrototypeFactory() &#123;</span><br><span class="line">    prototypes_[Type::PROTOTYPE_1] = new ConcretePrototype1(&quot;PROTOTYPE_1 &quot;, 50.f);</span><br><span class="line">    prototypes_[Type::PROTOTYPE_2] = new ConcretePrototype2(&quot;PROTOTYPE_2 &quot;, 60.f);</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  ~PrototypeFactory() &#123;</span><br><span class="line">    delete prototypes_[Type::PROTOTYPE_1];</span><br><span class="line">    delete prototypes_[Type::PROTOTYPE_2];</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  Prototype *CreatePrototype(Type type) &#123;</span><br><span class="line">    return prototypes_[type]-&gt;Clone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">void Client(PrototypeFactory &amp;prototype_factory) &#123;</span><br><span class="line">  std::cout &lt;&lt; &quot;Let&#x27;s create a Prototype 1\n&quot;;</span><br><span class="line">  # 这里通过原型创建复制的w类</span><br><span class="line">  Prototype *prototype = prototype_factory.CreatePrototype(Type::PROTOTYPE_1);</span><br><span class="line">  prototype-&gt;Method(90);</span><br><span class="line">  delete prototype;</span><br><span class="line">​</span><br><span class="line">  std::cout &lt;&lt; &quot;\n&quot;;</span><br><span class="line">​</span><br><span class="line">  std::cout &lt;&lt; &quot;Let&#x27;s create a Prototype 2 \n&quot;;</span><br><span class="line">​</span><br><span class="line">  prototype = prototype_factory.CreatePrototype(Type::PROTOTYPE_2);</span><br><span class="line">  prototype-&gt;Method(10);</span><br><span class="line">​</span><br><span class="line">  delete prototype;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">int main() &#123;</span><br><span class="line">  PrototypeFactory *prototype_factory = new PrototypeFactory();</span><br><span class="line">  Client(*prototype_factory);</span><br><span class="line">  delete prototype_factory;</span><br><span class="line">​</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/2024/07/22/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-22 14:40:31" itemprop="dateCreated datePublished" datetime="2024-07-22T14:40:31+08:00">2024-07-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="外观模式-Facade"><a href="#外观模式-Facade" class="headerlink" title="外观模式(Facade)"></a>外观模式(Facade)</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h2><ul>
<li><p><a href="#%E8%A7%A3%E6%9E%84%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F">解构外观模式</a></p>
</li>
<li><p><a href="#%E5%A4%96%E8%A7%82%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0">外观类的实现</a></p>
</li>
<li><p><a href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9">外观模式优缺点</a></p>
</li>
<li><p><a href="#%E4%BD%95%E6%97%B6%E9%80%89%E7%94%A8%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F">何时选用外观模式</a></p>
</li>
<li><p><a href="#%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%BC%8F">相关模式</a></p>
</li>
<li><p><a href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">具体实现</a></p>
</li>
</ul>
<p><strong>外观模式本质是封装交互。简化调用</strong></p>
<p>在设计模式中界面指从一个组件外部来看这个组件，public部分的内容就是这个组件的界面，即所谓的外观</p>
<p>外观模式通过引入一个外观类，在这个类里面定义客户端想要的简单方法，然后在这些方法的 实现里面，由外观类再去分别调用内部的多个模块来实现功能，从而让客户端变得简单。这样一来，客户端只需要和外观类交互就可以了。</p>
<ul>
<li><p>外观模式结构图</p>
<p>  <img src="https://isrootblog-1251140236.cos.ap-beijing.myqcloud.com/uPic/image_Uo8GqZbLg-.png"></p>
</li>
<li><p>外观模式整体示意结构图</p>
<p>  <img src="https://isrootblog-1251140236.cos.ap-beijing.myqcloud.com/uPic/image_npQKyuBeJ6.png"></p>
</li>
<li><p>外观模式调用顺序示意图</p>
<p>  <img src="https://isrootblog-1251140236.cos.ap-beijing.myqcloud.com/uPic/image_XZDXBKU8kk.png"></p>
</li>
</ul>
<h4 id="解构外观模式"><a href="#解构外观模式" class="headerlink" title="解构外观模式"></a>解构外观模式</h4><p>外观模式不是为了给子系统增加新的功能接口，而是为了让外部减少与子系统内多个模块交互。松散耦合。从而让外部能够更加简单的使用子系统，外观是当作子系统对外接口出现的。外观类中应该包装已经有的功能，它主要负责组合已有的功能来实现客户端的需要，不要去添加新的功能。</p>
<p>**<em>外观模式的本质</em>**：封装交互，简化调用</p>
<h4 id="外观类的实现"><a href="#外观类的实现" class="headerlink" title="外观类的实现"></a>外观类的实现</h4><p>对于一个子系统来说，外观类不需要很多，通常可以实现成为一个单例，也可以直接把外观中的方法实现成为静态的方法。</p>
<h4 id="外观模式优缺点"><a href="#外观模式优缺点" class="headerlink" title="外观模式优缺点"></a>外观模式优缺点</h4><ul>
<li><p>松散耦合</p>
<p>  外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能够更容易扩展和维护</p>
</li>
<li><p>简单易用</p>
<p>  外观模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟外观交互就可以了</p>
</li>
<li><p>更好的划分访问层次</p>
<p>  通过合理的使用Facade，可以帮助我们更好的划分访问的层次</p>
</li>
</ul>
<p>外观模式有如下缺点</p>
<p>过多的或者不太合理的Facade容易让人迷惑。</p>
<h4 id="何时选用外观模式"><a href="#何时选用外观模式" class="headerlink" title="何时选用外观模式"></a>何时选用外观模式</h4><ul>
<li><p>为复杂的子程序提供简单的访问接口。</p>
</li>
<li><p>让客户程序和抽象类的实现部分松散耦合</p>
</li>
<li><p>构建多层结构的系统</p>
</li>
</ul>
<h4 id="相关模式"><a href="#相关模式" class="headerlink" title="相关模式"></a>相关模式</h4><ul>
<li><p><strong>外观和中介模式</strong></p>
<p>  中介模式主要用来封装多个对象之间的相互交互。多用在系统内部的多个模块之间，外观模式封装的是单向交互，是从客户端到访问系统的调用</p>
<p>  在中介模式的实现里面，是需要实现具体的交互功能的；而外观模式的实现里面，一般是组合调用或者转调内部实现的功能。</p>
<p>  中介模式的目的主要是松散多个模块之间的耦合，把这些耦合关系全部放到中介者中去实现，而外观模式是简化客户端的调用。</p>
</li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a><strong>具体实现</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The Subsystem can accept requests either from the facade or client directly.</span><br><span class="line"> * In any case, to the Subsystem, the Facade is yet another client, and it&#x27;s not</span><br><span class="line"> * a part of the Subsystem.</span><br><span class="line"> */</span><br><span class="line">class Subsystem1 &#123;</span><br><span class="line"> public:</span><br><span class="line">  std::string Operation1() const &#123;</span><br><span class="line">    return &quot;Subsystem1: Ready!\n&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">  std::string OperationN() const &#123;</span><br><span class="line">    return &quot;Subsystem1: Go!\n&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">/**</span><br><span class="line"> * Some facades can work with multiple subsystems at the same time.</span><br><span class="line"> */</span><br><span class="line">class Subsystem2 &#123;</span><br><span class="line"> public:</span><br><span class="line">  std::string Operation1() const &#123;</span><br><span class="line">    return &quot;Subsystem2: Get ready!\n&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  // ...</span><br><span class="line">  std::string OperationZ() const &#123;</span><br><span class="line">    return &quot;Subsystem2: Fire!\n&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * The Facade class provides a simple interface to the complex logic of one or</span><br><span class="line"> * several subsystems. The Facade delegates the client requests to the</span><br><span class="line"> * appropriate objects within the subsystem. The Facade is also responsible for</span><br><span class="line"> * managing their lifecycle. All of this shields the client from the undesired</span><br><span class="line"> * complexity of the subsystem.</span><br><span class="line"> */</span><br><span class="line">class Facade &#123;</span><br><span class="line"> protected:</span><br><span class="line">  Subsystem1 *subsystem1_;</span><br><span class="line">  Subsystem2 *subsystem2_;</span><br><span class="line">  /**</span><br><span class="line">   * Depending on your application&#x27;s needs, you can provide the Facade with</span><br><span class="line">   * existing subsystem objects or force the Facade to create them on its own.</span><br><span class="line">   */</span><br><span class="line"> public:</span><br><span class="line">  /**</span><br><span class="line">   * In this case we will delegate the memory ownership to Facade Class</span><br><span class="line">   */</span><br><span class="line">  Facade(</span><br><span class="line">      Subsystem1 *subsystem1 = nullptr,</span><br><span class="line">      Subsystem2 *subsystem2 = nullptr) &#123;</span><br><span class="line">    this-&gt;subsystem1_ = subsystem1 ?: new Subsystem1;</span><br><span class="line">    this-&gt;subsystem2_ = subsystem2 ?: new Subsystem2;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Facade() &#123;</span><br><span class="line">    delete subsystem1_;</span><br><span class="line">    delete subsystem2_;</span><br><span class="line">  &#125;</span><br><span class="line">  /**</span><br><span class="line">   * The Facade&#x27;s methods are convenient shortcuts to the sophisticated</span><br><span class="line">   * functionality of the subsystems. However, clients get only to a fraction of</span><br><span class="line">   * a subsystem&#x27;s capabilities.</span><br><span class="line">   */</span><br><span class="line">  std::string Operation() &#123;</span><br><span class="line">    std::string result = &quot;Facade initializes subsystems:\n&quot;;</span><br><span class="line">    result += this-&gt;subsystem1_-&gt;Operation1();</span><br><span class="line">    result += this-&gt;subsystem2_-&gt;Operation1();</span><br><span class="line">    result += &quot;Facade orders subsystems to perform the action:\n&quot;;</span><br><span class="line">    result += this-&gt;subsystem1_-&gt;OperationN();</span><br><span class="line">    result += this-&gt;subsystem2_-&gt;OperationZ();</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">/**</span><br><span class="line"> * The client code works with complex subsystems through a simple interface</span><br><span class="line"> * provided by the Facade. When a facade manages the lifecycle of the subsystem,</span><br><span class="line"> * the client might not even know about the existence of the subsystem. This</span><br><span class="line"> * approach lets you keep the complexity under control.</span><br><span class="line"> */</span><br><span class="line">void ClientCode(Facade *facade) &#123;</span><br><span class="line">  // ...</span><br><span class="line">  std::cout &lt;&lt; facade-&gt;Operation();</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * The client code may have some of the subsystem&#x27;s objects already created. In</span><br><span class="line"> * this case, it might be worthwhile to initialize the Facade with these objects</span><br><span class="line"> * instead of letting the Facade create new instances.</span><br><span class="line"> */</span><br><span class="line">​</span><br><span class="line">int main() &#123;</span><br><span class="line">  Subsystem1 *subsystem1 = new Subsystem1;</span><br><span class="line">  Subsystem2 *subsystem2 = new Subsystem2;</span><br><span class="line">  Facade *facade = new Facade(subsystem1, subsystem2);</span><br><span class="line">  ClientCode(facade);</span><br><span class="line">​</span><br><span class="line">  delete facade;</span><br><span class="line">​</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/2024/07/22/%E5%85%B3%E4%BA%8E%E6%88%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/%E5%85%B3%E4%BA%8E%E6%88%91/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-22 14:40:31" itemprop="dateCreated datePublished" datetime="2024-07-22T14:40:31+08:00">2024-07-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a><strong>关于我</strong></h2><p>欢迎来到我的博客！ 我是一名多领域的开发工程师，擅长使用 C++、Python 和 Rust 进行软件开发。</p>
<p>我对编程和技术充满热情，并致力于不断学习和探索新的技术领域。 我拥有广泛的编程经验和技术知识。我在计算机科学领域取得了学士学位，并在多个项目中担任开发工程师的角色。</p>
<p>我在 C++、Python 和 Rust 方面有着深入的理解和实践经验，能够灵活地应用它们来解决各种编程问题。 我创建这个博客的目的是与大家分享我的编程经验、技术见解和最佳实践。我希望通过博客能够帮助读者解决实际的编程挑战，提供有价值的技术教程和指南。</p>
<p>在我的博客中，您将找到关于 C++、Python 和 Rust 的深入文章、教程和示例代码。我会分享我在这些领域的经验和见解，包括最新的开发技术、工具和框架。 我相信编程应该是一种有趣和创造性的体验，因此我会尽力使我的博客内容易于理解和实践。</p>
<p>如果您对任何文章或主题有疑问或建议，欢迎在评论区留言，我会尽快回复。 感谢您访问我的博客，希望您在这里找到有益的信息和灵感。让我们一起探索编程的奇妙世界！</p>
<p>如有任何疑问或合作机会，请通过以下方式与我联系：</p>
<ul>
<li><p><a href="mailto:电子邮件：your-email@example.com">电子邮件：wuxiaoning523@163.com</a></p>
</li>
<li><p>GitHub：<a target="_blank" rel="noopener" href="https://github.com/Lovening">https://github.com/Lovening</a></p>
</li>
</ul>
<p>谢谢！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/2024/07/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-22 14:40:31" itemprop="dateCreated datePublished" datetime="2024-07-22T14:40:31+08:00">2024-07-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式(Singleton)"></a>单例模式(Singleton)</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h2><ul>
<li><p><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89">单例模式的定义</a></p>
</li>
<li><p><a href="#%E6%87%92%E6%B1%89%E5%92%8C%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB">懒汉和饿汉模式的区别</a></p>
</li>
</ul>
<h3 id="单例模式的定义"><a href="#单例模式的定义" class="headerlink" title="单例模式的定义"></a><strong>单例模式的定义</strong></h3><p>单例模式保证一个类仅有一个实例，并且提供一个访问它的全局访问点,</p>
<p>单例模式分为饿汉模式和懒汉模式，从字面来理解，饿汉模式为一开始就创建好对象的实例，懒汉模式为使用的时候再去创建对象的实例</p>
<h3 id="懒汉和饿汉模式的区别"><a href="#懒汉和饿汉模式的区别" class="headerlink" title="懒汉和饿汉模式的区别"></a><strong>懒汉和饿汉模式的区别</strong></h3><p>NaN. 时间和空间</p>
<pre><code>懒汉式是典型的时间换空间，也就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间

饿汉式是典型的空间换时间。当类装载的时候就会创建类实例，不管你用不用，先创建出来，然后每次调用的时候就不需要再次判断了，节省了运行时间
</code></pre>
<p>NaN. 线程安全</p>
<pre><code>从线程安全性上讲，不同步加载的懒汉模式是线程不安全的。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/2024/07/22/%E4%BD%BF%E7%94%A8boost%E5%BA%93%E6%93%8D%E4%BD%9CC++%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/07/22/%E4%BD%BF%E7%94%A8boost%E5%BA%93%E6%93%8D%E4%BD%9CC++%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-22 14:40:31" itemprop="dateCreated datePublished" datetime="2024-07-22T14:40:31+08:00">2024-07-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h6 id="字符串的查找与替换一直是-C-的弱势，运用-Boost-这个准标准库，将可以很好的弥补-C-的不足，使针对字符串的操作更加容易。"><a href="#字符串的查找与替换一直是-C-的弱势，运用-Boost-这个准标准库，将可以很好的弥补-C-的不足，使针对字符串的操作更加容易。" class="headerlink" title="字符串的查找与替换一直是 C++的弱势，运用 Boost 这个准标准库，将可以很好的弥补 C++的不足，使针对字符串的操作更加容易。"></a>字符串的查找与替换一直是 C++的弱势，运用 Boost 这个准标准库，将可以很好的弥补 C++的不足，使针对字符串的操作更加容易。</h6><h4 id="字符串格式转换"><a href="#字符串格式转换" class="headerlink" title="字符串格式转换:"></a>字符串格式转换:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\lexical_cast.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str[<span class="number">3</span>] = &#123; <span class="string">&quot;100&quot;</span>, <span class="string">&quot;102&quot;</span>, <span class="string">&quot;3.14159&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串转换为数值类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符串转为整数: &quot;</span> &lt;&lt; <span class="built_in">lexical_cast</span>&lt;<span class="type">int</span>&gt;(str[<span class="number">0</span>]) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符串转为长整数: &quot;</span> &lt;&lt; <span class="built_in">lexical_cast</span>&lt;<span class="type">long</span>&gt;(str[<span class="number">1</span>]) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符串转为浮点数: &quot;</span> &lt;&lt; <span class="built_in">lexical_cast</span>&lt;<span class="type">float</span>&gt;(str[<span class="number">2</span>]) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数值类型转化为字符串</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;数值转为字符串: &quot;</span> &lt;&lt; <span class="built_in">lexical_cast</span>&lt;string&gt;(<span class="number">100</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;十六进制转为十进制: &quot;</span> &lt;&lt; <span class="built_in">lexical_cast</span>&lt;string&gt;(<span class="number">0x10</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="format格式化："><a href="#format格式化：" class="headerlink" title="format格式化："></a>format格式化：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\format.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 第一种输出方式: 直接填充字符串</span></span><br><span class="line">    <span class="function">boost::format <span class="title">fmtA</span><span class="params">(<span class="string">&quot;姓名: %s -&gt; 年龄: %d -&gt; 性别: %s&quot;</span>)</span></span>;</span><br><span class="line">    fmtA %<span class="string">&quot;lyshark&quot;</span>;</span><br><span class="line">    fmtA % <span class="number">22</span>;</span><br><span class="line">    fmtA %<span class="string">&quot;男&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string str = fmtA.<span class="built_in">str</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;格式化后: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种方式: 拷贝的使用</span></span><br><span class="line">    <span class="function">boost::format <span class="title">fmtB</span><span class="params">(<span class="string">&quot;姓名: %s -&gt; 年龄: %d -&gt; 性别: %s&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; format(fmtB) % <span class="string">&quot;lyshark&quot;</span> % <span class="number">23</span> % <span class="string">&quot;男&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="string-algo-大小写转化函数"><a href="#string-algo-大小写转化函数" class="headerlink" title="string_algo 大小写转化函数"></a><code>string_algo</code> 大小写转化函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\algorithm\string.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;readme.log&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ends_with</span>(str, <span class="string">&quot;log&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;转化为大写: &quot;</span> &lt;&lt; <span class="built_in">to_upper_copy</span>(str) &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;转化为小写: &quot;</span> &lt;&lt; <span class="built_in">to_lower_copy</span>(str) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换开头</span></span><br><span class="line">    <span class="built_in">replace_first</span>(str, <span class="string">&quot;readme&quot;</span>, <span class="string">&quot;lyshark&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;替换开头: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行删除后缀</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">v</span><span class="params">(str.begin(), str.end())</span></span>;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; v2 = <span class="built_in">to_upper_copy</span>(<span class="built_in">erase_first_copy</span>(v, <span class="string">&quot;.log&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : v2)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; x ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断类"><a href="#判断类" class="headerlink" title="判断类"></a>判断类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\algorithm\string.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string str[<span class="number">6</span>] = &#123; <span class="string">&quot;hello lyshark&quot;</span>, <span class="string">&quot;hello LyShark&quot;</span>, <span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;FCE&quot;</span> ,<span class="string">&quot;lyshark&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;大小写不敏感判断后缀: &quot;</span> &lt;&lt; <span class="built_in">iends_with</span>(str[<span class="number">0</span>], <span class="string">&quot;lyshark&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;大小写敏感判断前缀: &quot;</span> &lt;&lt; <span class="built_in">starts_with</span>(str[<span class="number">1</span>], <span class="string">&quot;Hello&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;测试包含关系: &quot;</span> &lt;&lt; <span class="built_in">contains</span>(str[<span class="number">0</span>], str[<span class="number">5</span>]) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;测试前5个字母是否为小写: &quot;</span> &lt;&lt; <span class="built_in">all</span>(str[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>), <span class="built_in">is_lower</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">is_any_of</span>()</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修正"><a href="#修正" class="headerlink" title="修正"></a>修正</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\format.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\algorithm\string.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string str[<span class="number">3</span>] = &#123; <span class="string">&quot;hello LyShark&quot;</span>, <span class="string">&quot;hello LyShark&quot;</span>, <span class="string">&quot;lyshark&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;大小写不敏感判断后缀: &quot;</span> &lt;&lt; <span class="built_in">iends_with</span>(str[<span class="number">0</span>], <span class="string">&quot;lyshark&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;大小写敏感判断前缀: &quot;</span> &lt;&lt; <span class="built_in">starts_with</span>(str[<span class="number">1</span>], <span class="string">&quot;Hello&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;测试包含关系: &quot;</span> &lt;&lt; <span class="built_in">contains</span>(str[<span class="number">0</span>], str[<span class="number">2</span>]) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;前5个字母是否为小写: &quot;</span> &lt;&lt; <span class="built_in">all</span>(str[<span class="number">0</span>].<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>), <span class="built_in">is_lower</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;前2个字符是否为字母: &quot;</span> &lt;&lt; <span class="built_in">all</span>(str[<span class="number">1</span>].<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">2</span>), <span class="built_in">is_alpha</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串修剪 去空格</span></span><br><span class="line">    <span class="function">boost::format <span class="title">fmt</span><span class="params">(<span class="string">&quot;|%s|\n&quot;</span>)</span></span>;</span><br><span class="line">    std::string my_string = <span class="string">&quot;   hello  lyshark   &quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除两端空格: &quot;</span> &lt;&lt; fmt %<span class="built_in">trim_copy</span>(my_string) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除左端空格: &quot;</span> &lt;&lt; fmt %<span class="built_in">trim_left_copy</span>(my_string) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">trim_right</span>(my_string);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原地删除右端空格: &quot;</span> &lt;&lt; fmt %my_string &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串修建 去特殊符号</span></span><br><span class="line">    std::string my_stringa = <span class="string">&quot;2021 happy new Year !!!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除左端数字: &quot;</span> &lt;&lt; fmt %<span class="built_in">trim_left_copy_if</span>(my_stringa, <span class="built_in">is_digit</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除右端标点: &quot;</span> &lt;&lt; fmt %<span class="built_in">trim_right_copy_if</span>(my_stringa, <span class="built_in">is_punct</span>()) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除两端(标点|数字|空格): &quot;</span> &lt;&lt; <span class="built_in">trim_copy_if</span>(my_stringa, <span class="built_in">is_punct</span>() || <span class="built_in">is_digit</span>() || <span class="built_in">is_space</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\format.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\algorithm\string.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">boost::format <span class="title">fmt</span><span class="params">(<span class="string">&quot;|%s|. pos = %d\n&quot;</span>)</span></span>;</span><br><span class="line">    std::string my_string = <span class="string">&quot;Long long ago, there was Ago king as long.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    iterator_range&lt;std::string::iterator&gt; reg;   <span class="comment">// 定义迭代区间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找第一次出现的位置(大小写敏感)</span></span><br><span class="line">    reg = <span class="built_in">find_first</span>(my_string, <span class="string">&quot;Ago&quot;</span>);</span><br><span class="line">    cout &lt;&lt; fmt %reg % (reg.<span class="built_in">begin</span>() - my_string.<span class="built_in">begin</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找最后一次出现的位置(大小写不敏感)</span></span><br><span class="line">    reg = ifind_last(my_string, <span class="string">&quot;ago&quot;</span>);</span><br><span class="line">    cout &lt;&lt; fmt %reg % (reg.<span class="built_in">begin</span>() - my_string.<span class="built_in">begin</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找第三次出现long的位置(大小写不敏感)</span></span><br><span class="line">    reg = ifind_nth(my_string, <span class="string">&quot;long&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; fmt %reg % (reg.<span class="built_in">begin</span>() - my_string.<span class="built_in">begin</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取前四个字符和后四个字符</span></span><br><span class="line">    reg = <span class="built_in">find_head</span>(my_string, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; fmt %reg % (reg.<span class="built_in">begin</span>() - my_string.<span class="built_in">begin</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    reg = <span class="built_in">find_tail</span>(my_string, <span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; fmt %reg % (reg.<span class="built_in">begin</span>() - my_string.<span class="built_in">begin</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找不到则输出</span></span><br><span class="line">    reg = <span class="built_in">find_first</span>(my_string, <span class="string">&quot;lyshark&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;flag = &quot;</span> &lt;&lt; (reg.<span class="built_in">empty</span>() &amp;&amp; !reg) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="替换与删除-注意带有-copy的为拷贝，代表可以使用string变量来接收，不带的直接操作原始字符串。"><a href="#替换与删除-注意带有-copy的为拷贝，代表可以使用string变量来接收，不带的直接操作原始字符串。" class="headerlink" title="替换与删除 注意带有_copy的为拷贝，代表可以使用string变量来接收，不带的直接操作原始字符串。"></a>替换与删除 注意带有_copy的为拷贝，代表可以使用string变量来接收，不带的直接操作原始字符串。</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\format.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\algorithm\string.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">boost::format <span class="title">fmt</span><span class="params">(<span class="string">&quot;|%s|. pos = %d\n&quot;</span>)</span></span>;</span><br><span class="line">    std::string my_string = <span class="string">&quot;Long long ago, there was Ago king as long.&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换开头字符串(两种替换方式)</span></span><br><span class="line">    std::string str_copy = <span class="built_in">replace_first_copy</span>(my_string, <span class="string">&quot;long&quot;</span>, <span class="string">&quot;LONG&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;替换后返回字符串: &quot;</span> &lt;&lt; str_copy &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">replace_first</span>(my_string, <span class="string">&quot;ago&quot;</span>, <span class="string">&quot;AGO&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;直接替换在原始字符串上: &quot;</span> &lt;&lt; my_string &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换开头或结尾前后5个字符</span></span><br><span class="line">    <span class="built_in">replace_tail</span>(my_string, <span class="number">5</span>, <span class="string">&quot;lyshark&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;替换结尾5个字符: &quot;</span> &lt;&lt; my_string &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">replace_head</span>(my_string, <span class="number">5</span>, <span class="string">&quot;lyshark&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;替换开头5个字符: &quot;</span> &lt;&lt; my_string &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换第一次出现long的位置为AGES</span></span><br><span class="line">    <span class="built_in">replace_nth</span>(my_string, <span class="string">&quot;long&quot;</span>, <span class="number">0</span>, <span class="string">&quot;AGES&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一次出现位置: &quot;</span> &lt;&lt; my_string &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 替换所有出现过的位置</span></span><br><span class="line">    std::string str_copy_a = <span class="built_in">replace_all_copy</span>(my_string, <span class="string">&quot;lyshark&quot;</span>, <span class="string">&quot;LYSSHARK&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;替换所有位置: &quot;</span> &lt;&lt; str_copy_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第1次出现was位置的字符串</span></span><br><span class="line">    std::string del_str_copy = <span class="built_in">erase_nth_copy</span>(my_string, <span class="string">&quot;was&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除后的字符串: &quot;</span> &lt;&lt; del_str_copy &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除字符串中所有的LYSSHARK</span></span><br><span class="line">    <span class="built_in">erase_all</span>(my_string, <span class="string">&quot;LYSSHARK&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除后的字符串: &quot;</span> &lt;&lt; my_string &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="切割合并字符串："><a href="#切割合并字符串：" class="headerlink" title="切割合并字符串："></a>切割合并字符串：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\algorithm\string.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\assign.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string my_string = <span class="string">&quot;lyshark,Link.Zelda:Mario-Ligui+zelda,ZELDA&quot;</span>;</span><br><span class="line">    <span class="function">std::string <span class="title">my_string_b</span><span class="params">(<span class="string">&quot;hello||lyshark||welcome||link&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找字符串中的特定字符串</span></span><br><span class="line">    deque&lt;std::string&gt; deq;</span><br><span class="line"></span><br><span class="line">    ifind_all(deq, my_string, <span class="string">&quot;zelda&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;查找字符串个数(不区分大小写): &quot;</span> &lt;&lt; deq.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (deq.<span class="built_in">size</span>() == <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> each : deq)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[ &quot;</span> &lt;&lt; each &lt;&lt; <span class="string">&quot; ]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切割字符串(1)</span></span><br><span class="line">    list&lt;iterator_range&lt;std::string::iterator&gt;&gt; ptr;</span><br><span class="line">    <span class="built_in">split</span>(ptr, my_string, <span class="built_in">is_any_of</span>(<span class="string">&quot;,.:-+&quot;</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> each : ptr)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[ &quot;</span> &lt;&lt; each &lt;&lt; <span class="string">&quot; ]&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切割字符串(2)</span></span><br><span class="line">    ptr.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">split</span>(ptr, my_string, <span class="built_in">is_any_of</span>(<span class="string">&quot;.:-&quot;</span>), token_compress_on);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> each : ptr)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[ &quot;</span> &lt;&lt; each &lt;&lt; <span class="string">&quot; ]&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并字符串</span></span><br><span class="line">    std::vector&lt;string&gt; vct;</span><br><span class="line"></span><br><span class="line">    vct.<span class="built_in">push_back</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    vct.<span class="built_in">push_back</span>(<span class="string">&quot;lyshark&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;用空格将其连接起来: &quot;</span> &lt;&lt; <span class="built_in">join</span>(vct, <span class="string">&quot; &quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找迭代器的使用</span></span><br><span class="line">    <span class="keyword">typedef</span> find_iterator&lt;string::iterator&gt; string_find_iterator;</span><br><span class="line">    string_find_iterator pos, end;</span><br><span class="line">    <span class="keyword">for</span> (pos = <span class="built_in">make_find_iterator</span>(my_string_b, <span class="built_in">first_finder</span>(<span class="string">&quot;lyshark&quot;</span>, <span class="built_in">is_iequal</span>())); pos != end; ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[ &quot;</span> &lt;&lt; *pos &lt;&lt; <span class="string">&quot; ]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分割迭代器的使用</span></span><br><span class="line">    <span class="keyword">typedef</span> split_iterator&lt;string::iterator&gt; string_split_iterator;</span><br><span class="line">    string_split_iterator p, endp;</span><br><span class="line">    <span class="keyword">for</span> (p = <span class="built_in">make_split_iterator</span>(my_string_b, <span class="built_in">first_finder</span>(<span class="string">&quot;||&quot;</span>, <span class="built_in">is_iequal</span>())); p != endp; ++p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[ &quot;</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot; ]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="正则模块的使用"><a href="#正则模块的使用" class="headerlink" title="正则模块的使用:"></a>正则模块的使用:</h4><ul>
<li>正则匹配</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\algorithm\string.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\xpressive\xpressive.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::xpressive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简单匹配字符串</span></span><br><span class="line">    cregex regxA = cregex::<span class="built_in">compile</span>(<span class="string">&quot;a.c&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配字符串: &quot;</span> &lt;&lt; <span class="built_in">regex_match</span>(<span class="string">&quot;abd&quot;</span>, regxA) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    std::string StringA = <span class="string">&quot;hello lyshark a.c&quot;</span>;</span><br><span class="line">    cregex regxD = cregex::<span class="built_in">compile</span>(<span class="string">&quot;a.c&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配字符串: &quot;</span> &lt;&lt; <span class="built_in">regex_match</span>((<span class="type">char</span> *)&amp;StringA, regxD) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组方式引用正则</span></span><br><span class="line">    cregex_compiler regc;</span><br><span class="line"></span><br><span class="line">    regc[<span class="string">&quot;regxA&quot;</span>] = regc.<span class="built_in">compile</span>(<span class="string">&quot;a|b|c&quot;</span>);</span><br><span class="line">    regc[<span class="string">&quot;regxB&quot;</span>] = regc.<span class="built_in">compile</span>(<span class="string">&quot;\d*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">regex_match</span>(<span class="string">&quot;abcdefg&quot;</span>, regc[<span class="string">&quot;regxA&quot;</span>]) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">regex_match</span>(<span class="string">&quot;123123&quot;</span>, regc[<span class="string">&quot;regxB&quot;</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用C++ 11 匹配身份证</span></span><br><span class="line">    cregex regxB = cregex::<span class="built_in">compile</span>(<span class="string">R&quot;---(\d&#123;6&#125;(1|2)\d&#123;3&#125;(0|1)\d[0-3]\d\d&#123;3&#125;(X|\d))---&quot;</span>, icase);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;验证身份证: &quot;</span> &lt;&lt; <span class="built_in">regex_match</span>(<span class="string">&quot;513436200002247099&quot;</span>, regxB) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用C++ 98 匹配身份证</span></span><br><span class="line">    cregex regxC = cregex::<span class="built_in">compile</span>(<span class="string">&quot;\d&#123;6&#125;((1|2)\d&#123;3&#125;)((0|1)\d)([0-3]\d)(\d&#123;3&#125;(X|\d))&quot;</span>, icase);</span><br><span class="line">    cmatch what;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">regex_match</span>(<span class="string">&quot;513436200002247099&quot;</span>, what, regxC);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;each : what)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[ &quot;</span> &lt;&lt; each &lt;&lt; <span class="string">&quot; ]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;生日为: &quot;</span> &lt;&lt; what[<span class="number">1</span>] &lt;&lt; what[<span class="number">3</span>] &lt;&lt; what[<span class="number">5</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正则匹配开头结尾</span></span><br><span class="line">    <span class="function">string <span class="title">StringB</span><span class="params">(<span class="string">&quot;lyshark.log&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    sregex start_regx = sregex::<span class="built_in">compile</span>(<span class="string">&quot;^ly.*&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配开头: &quot;</span> &lt;&lt; <span class="built_in">regex_match</span>(StringB, start_regx) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    sregex end_regx = sregex::<span class="built_in">compile</span>(<span class="string">&quot;.*log$&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;匹配结尾: &quot;</span> &lt;&lt; <span class="built_in">regex_match</span>(StringB, end_regx) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>正则查找替换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\algorithm\string.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\xpressive\xpressive.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::xpressive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正则查找特定字符串</span></span><br><span class="line">    <span class="type">char</span> my_stringA[] = <span class="string">&quot;This is power-studio territory&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cregex regx = cregex::<span class="built_in">compile</span>(<span class="string">&quot;(power)-(.&#123;6&#125;)&quot;</span>, icase);</span><br><span class="line">    cmatch what;</span><br><span class="line">    <span class="built_in">regex_search</span>(my_stringA, what, regx);</span><br><span class="line">    <span class="keyword">if</span> (what.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; what.<span class="built_in">size</span>(); x++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; what[x] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正则替换特定字符串</span></span><br><span class="line">    std::string my_stringB = <span class="string">&quot;2020 Happy New Year !!!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    sregex regxA = sregex::<span class="built_in">compile</span>(<span class="string">&quot;^(\d| )*&quot;</span>);    <span class="comment">// 匹配开头数字</span></span><br><span class="line">    sregex regxB = sregex::<span class="built_in">compile</span>(<span class="string">&quot;!*$&quot;</span>);         <span class="comment">// 匹配末尾标点符号</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">regex_replace</span>(my_stringB, regxA, <span class="string">&quot;2021&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">regex_replace</span>(my_stringB, regxB, <span class="string">&quot;&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>正则迭代与分词</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\algorithm\string.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\xpressive\xpressive.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost\xpressive\regex_iterator.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> boost::xpressive;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正则迭代输出</span></span><br><span class="line">    std::string my_string_a = <span class="string">&quot;power-shell, power-studio,power-engine,super-user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    sregex regxA = sregex::<span class="built_in">compile</span>(<span class="string">&quot;power-(\w&#123;5&#125;)&quot;</span>, icase);</span><br><span class="line"></span><br><span class="line">    <span class="function">sregex_iterator <span class="title">start_ptr</span><span class="params">(my_string_a.begin(), my_string_a.end(), regxA)</span></span>;</span><br><span class="line">    sregex_iterator end_ptr;</span><br><span class="line">    <span class="keyword">for</span> (; start_ptr != end_ptr; ++start_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[ &quot;</span> &lt;&lt; (*start_ptr)[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; ]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正则分词</span></span><br><span class="line">    <span class="type">char</span> my_string_b[] = <span class="string">&quot;*lyshark*||+administrator+||root!!||metaper&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cregex regxB = cregex::<span class="built_in">compile</span>(<span class="string">&quot;\w+&quot;</span>, icase);   <span class="comment">// 过滤出所有的字母</span></span><br><span class="line">    <span class="function">cregex_token_iterator <span class="title">pos</span><span class="params">(my_string_b, my_string_b + strlen(my_string_b), regxB)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (; pos != <span class="built_in">cregex_token_iterator</span>(); ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[ &quot;</span> &lt;&lt; *pos &lt;&lt; <span class="string">&quot; ]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正则切割</span></span><br><span class="line">    cregex split_regx = cregex::<span class="built_in">compile</span>(<span class="string">&quot;\|\|&quot;</span>);</span><br><span class="line">    pos = <span class="built_in">cregex_token_iterator</span>(my_string_b, my_string_b + <span class="built_in">strlen</span>(my_string_b), split_regx, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (; pos != <span class="built_in">cregex_token_iterator</span>(); ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;[ &quot;</span> &lt;&lt; *pos &lt;&lt; <span class="string">&quot; ]&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正则格式化(小写转大写)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">formater</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">string <span class="title">operator</span><span class="params">()</span><span class="params">(cmatch <span class="type">const</span> &amp;m)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> boost::<span class="built_in">to_upper_copy</span>(m[<span class="number">0</span>].<span class="built_in">str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> my_string_c[] = <span class="string">&quot;*lyshark*||+administrator+||root!!||metaper&quot;</span>;</span><br><span class="line">    cregex regxC = cregex::<span class="built_in">compile</span>(<span class="string">&quot;\w+&quot;</span>, icase);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">regex_replace</span>(my_string_c, regxC, formater()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分词器使用:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/tokenizer.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    std::string strTag = <span class="string">&quot;explorer.exe,1024&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义分割符号为逗号与空格 定义分词器</span></span><br><span class="line">    <span class="function">boost::char_separator&lt;<span class="type">char</span>&gt; <span class="title">sep</span><span class="params">(<span class="string">&quot;, &quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> boost::tokenizer&lt;boost::char_separator&lt;<span class="type">char</span>&gt;&gt; CustonTokenizer;</span><br><span class="line">    <span class="function">CustonTokenizer <span class="title">tok</span><span class="params">(strTag, sep)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将分词结果放入vector链表</span></span><br><span class="line">    std::vector&lt;std::string&gt; vecSegTag;</span><br><span class="line">    <span class="keyword">for</span> (CustonTokenizer::iterator beg = tok.<span class="built_in">begin</span>(); beg != tok.<span class="built_in">end</span>(); ++beg)</span><br><span class="line">    &#123;</span><br><span class="line">        vecSegTag.<span class="built_in">push_back</span>(*beg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const_case 将string转换为char 8</span></span><br><span class="line">    std::string ref_string = <span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(vecSegTag[<span class="number">0</span>].<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;进程名: &quot;</span> &lt;&lt; ref_string &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;分词数: &quot;</span> &lt;&lt; vecSegTag.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">吴晓宁</p>
  <div class="site-description" itemprop="description">记录一些自己的见闻</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴晓宁</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
