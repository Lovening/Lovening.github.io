<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.isroots.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录一些自己的见闻">
<meta property="og:type" content="website">
<meta property="og:title" content="吴晓宁blog">
<meta property="og:url" content="https://blog.isroots.com/page/5/index.html">
<meta property="og:site_name" content="吴晓宁blog">
<meta property="og:description" content="记录一些自己的见闻">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="吴晓宁">
<meta property="article:tag" content="blog,编程">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.isroots.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>吴晓宁blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">吴晓宁blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">吴晓宁blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/242024/09/03/%E5%9C%A8github%20%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8C%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/242024/09/03/%E5%9C%A8github%20%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%92%8C%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94/" class="post-title-link" itemprop="url">在github 搭建免费私有仓库和本地仓库关联</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：242024-09-03 16:28:00" itemprop="dateCreated datePublished" datetime="242024-09-03T16:28:00+08:00">242024-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-03 16:29:28" itemprop="dateModified" datetime="2024-09-03T16:29:28+08:00">2024-09-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Github被微软收购后，今年重大的更新就是个人开发者可以免费的创建私人仓库并且无限制。但是个人仓库最多可以邀请三个人协和开发。这个对于小型项目来说应该足够了。我准备将自己学习时使用的代码上传到GITHUB。方便自己在任何地方都可以随时查阅。</p>
<h2 id="1-创建远程仓库"><a href="#1-创建远程仓库" class="headerlink" title="1.创建远程仓库"></a>1.创建远程仓库</h2><p>首先在github 上创建个人的私人仓库,登陆github，点击右上方“+”号，选择“New repository”，输入仓库名，在Repository name 中输入你想创建的仓库名称就行，然后选择私有仓库，点击创建即可。<br><img src="http://isroot.cn/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif"></p>
<p>下图是我创建好的仓库<br><img src="http://isroot.cn/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif"><br>可以看到在我的仓库名称那可以看到private</p>
<h2 id="2-创建本地仓库"><a href="#2-创建本地仓库" class="headerlink" title="2 .创建本地仓库"></a>2 .创建本地仓库</h2><p>因为我是在windows上操作的。这里只记录在windows上的操作。linux和mac系统的都是类似的步骤。<br>– 2.1 下载github的客户端，然后安装。我都是默认安装的<br>– 2.2 安装完成后，在开始菜单-&gt;所有程序，就会找到git Bash<br>打开git Bash,蹦出一个类似cmd窗口的东西，就说明git安装成功<br><img src="http://isroot.cn/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif"><br>安装完成后，要告诉git你的用户名和邮箱，输入以下命令<br><code>git config --global user.name &quot;your name&quot;</code><br><code>git config --global user.email &quot;your@email.com&quot;</code><br>这里的 “”里面的要换成你自己的名字和email<br>– 2.3 安装 Git 之后，就可以在我们自己的电脑上来创建本地仓库了。仓库（Repository）可以简单理解为一个目录，每个目录包含着一个仓库。首先，我们可以在自己电脑的任意位置新建一个文件夹（例如 E: Git&#x2F; 目录），该目录作为 Git 的管理目录，所有的仓库都将建立在此目录下。在此目录下，我们要建立一个仓库，名为 learngit。打开 Git Bash，cd 到 Git&#x2F; 目录下，新建一个目录 learngit，再 cd 到 learngit 目录，命令如下：<br><code>mkdir learngit</code><br><code>cd learngit</code><br>然后，使用下面的命令将 learngit 目录变成 Git 可以管理的仓库：<br><code>git init</code><br>运行该命令之后，就可以在 learngit 目录下生成一个 .git 隐藏文件夹，表示初始化成功，该目录已经可以被 Git 管理了。现在 learngit 就称为我们的git仓库了。<br>现在，我们已经创建了一个空的仓库 learngit，下一步往仓库里加点内容。例如在该仓库目录下新建一个 readme.md 文件。将该文件添加到仓库中需要两个步骤：<br>– 2.3.1.用命令 git add 告诉git。把文件添加到仓库:<br><code>git add readme.md</code><br>– 2.3.2.用命令 git commit 告诉git，把文件提交到仓库<br><code>git commit -m &quot;create readme file&quot;</code><br>其中 -m 后面是本次提交的说明，最好说明是有意义的，这样你就能从历史记录里面方便找到你更改的历史。</p>
<h1 id="3-将本地仓库关联到远程仓库"><a href="#3-将本地仓库关联到远程仓库" class="headerlink" title="3.将本地仓库关联到远程仓库"></a>3.将本地仓库关联到远程仓库</h1><p>这时候，你的本地 Git 仓库与 GitHub 远程仓库还没有办法传输的，由于使用的是 SSH 加密，需要进行以下设置。<br>– 3.1 创建SSH Key,在用户主目录下面，看看有没有.ssh。如果有，再看看这个目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开终端（Windows 下打开 Git Bash），创建 SSH Key<br><code>ssh-keygen -t rsa -C &quot;youremail@mail.com&quot;</code> 一直回车就OK<br>这里记录下，这个会在你主用户目录下创建一个.ssh 的隐藏目录。比如我的电脑用户名是DIY-PC，那么这个隐藏目录就在C:\Users\DIY\ 下面，记得看你上面的目录是在哪个目录执行的。记得打开显示隐藏目录。然后就找到了。<br>– 3.2 登录自己的 GitHub，点击页面右上角 Settings 选项。<br><img src="http://isroot.cn/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif"><br>点击SSH and GPG keys:<br><img src="http://isroot.cn/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif"><br>点击 New SSH key 后，输入 Title 和 Key。重点来了，Key 就是你电脑的 id_rsa.pub 里的内容，直接复制过来就好<br><img src="http://isroot.cn/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif"><br>点击 Add SSH key，就完成了 SSH 的配置。之所以要设置 SSH key，是为了识别出你推送的确实是你推送的，而不是别人冒充的，而 Git 支持 SSH 协议，所以，GitHub 只要知道了你的公钥，就可以确认只有你自己才能推送。如果你有两个电脑，比如公司一个，家里一个。那么可以把两台电脑的公钥都添加到你的 GitHub，这样就都可以实现推送了。</p>
<h1 id="4-将本地上传的GitHub"><a href="#4-将本地上传的GitHub" class="headerlink" title="4.将本地上传的GitHub"></a>4.将本地上传的GitHub</h1><ul>
<li><p>4.1 其实，本地 Git 仓库与 GitHub 的互连有两种形式，我们首先介绍第一种方式：从本地上传到 GitHub。<br>  刚才我们已经在github创建了一个私人仓库，点开我们的仓库，点击Clone or Download 复制下git的地址，如下图：<br>  <img src="http://isroot.cn/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif"></p>
<ul>
<li>4.2 回到我们的 Git Bash 界面，把本地 Git 库与刚刚建的远程仓库关联，输入下列命令<br>  <code>git remote add origin https://github.com/yourname/learngit.git</code><br>  origin 是你刚才复制的地址，这条命令是添加一个远程仓库</li>
<li>4.3下一步就是把本地仓库的所有文件（刚刚新建的 readme.md）上传到 GitHub 上。运行以下命令：<br>  <code>git push -u origin master</code><br>  运行命令之后，出现如下提示:<br>  <img src="http://isroot.cn/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif"><br>  这里要输入yes 不能直接回车的<br>  然后在push 你可能会遇到push 不上去的错误，这是因为我们远程仓库和本地仓库不一致的原因，解决办法这里贴个博客，自己看<a target="_blank" rel="noopener" href="https://gitbook.tw/chapters/github/fail-to-push.html">https://gitbook.tw/chapters/github/fail-to-push.html</a>。<br>  先将远程仓库和本地合并，如果你在合并的时候出现“fatal: refusing to merge unrelated histories”。这里的解决办法是<a target="_blank" rel="noopener" href="http://isroot.cn/work/jiejuegitzhongfatalrefusingtomergeunrelatedhistories/">http://isroot.cn/work/jiejuegitzhongfatalrefusingtomergeunrelatedhistories/</a><br>  然后就可以push 了，执行 <code>git push -u origin master</code><br>  将我们本地的文件就可以推到自己的仓库里面了。推完后我的github仓库已经出现了本地的代码。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/242024/09/03/QFile%20%E4%B8%8D%E8%83%BD%E4%BB%A5%20WriteOlny,ReadWrite%20%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/242024/09/03/QFile%20%E4%B8%8D%E8%83%BD%E4%BB%A5%20WriteOlny,ReadWrite%20%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">QFile 不能以 WriteOlny,ReadWrite 方式打开资源文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：242024-09-03 16:18:00" itemprop="dateCreated datePublished" datetime="242024-09-03T16:18:00+08:00">242024-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-03 16:18:47" itemprop="dateModified" datetime="2024-09-03T16:18:47+08:00">2024-09-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题的产生"><a href="#问题的产生" class="headerlink" title="问题的产生"></a>问题的产生</h2><ul>
<li>在写软件配置信息文件的时候一般采用.xml文件，以前做的时候都是采用的相对路径或者添加环境变量的方式来确定文件的路径。这次在做新的项目的时候，想着是否可以将xml配置文件添加到资源文件，这样文件的路径就固定了，在后期打包安装的时候也方便一些。然后将配置文件就添加到资源文件中。在使用的时候因为配置文件都是提前写好的，在读取的时候没有任何问题。但在修改配置文件的时候发现文件无法使用WriteOlny,ReadWrite方式打开。但使用路径的方式就可以打开。</li>
</ul>
<h2 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h2><ul>
<li>qt的资源文件中在程序中是以二进制的形式存在的，当你编译完成后，就被当成程序的一部分增加到了源码中，试想下，你程序在运行的时候你能修改源码吗。</li>
<li>Qt 资源系统是一个跨平台的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也不需要担心这些文件的丢失。也就是说，如果你将资源以资源文件形式存储，它是会编译到可执行文件内部。<br>  所以，当我们只需要一些只读资源的时候，比如图片，或者软件不会被修改的配置文件，是可以放到资源文件中的。如果需要在运行时修改的文件。不要放到资源文件中</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/242024/09/03/QDomNode%20setNodeValue%20%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/242024/09/03/QDomNode%20setNodeValue%20%E6%97%A0%E6%95%88%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">QDomNode setNodeValue 无效问题记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：242024-09-03 16:13:00" itemprop="dateCreated datePublished" datetime="242024-09-03T16:13:00+08:00">242024-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-03 16:15:38" itemprop="dateModified" datetime="2024-09-03T16:15:38+08:00">2024-09-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>在使用QDOM 类操作xml 的时候，更新一个QDomNode 的值，查看Qt的帮助文档<br><code>void QDomNode::setNodeValue(const QString &amp; v)</code><br><code>Sets the node&#39;s value to v.</code><br>看翻译这个函数应该是可以设置QDomNode的value。但在具体使用的发现xml文档的值并没有发生改变，使用方法为下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这里简写代码  xml的打开和保存不在这里写了</span><br><span class="line">QDomNode node.firstChild().setNodeValue(&quot;value&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>代码运行完后发现xml的值并没有发生改变，去重新查看文档，查看相关函数 nodeValue()时发现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString QDomNode::nodeValue() const</span><br><span class="line">Returns the value of the node.</span><br><span class="line"></span><br><span class="line">The meaning of the value depends on the subclass:</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>Name</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>QDomAttr</td>
<td>The attribute value</td>
</tr>
<tr>
<td>QDomCDATASection</td>
<td>The content of the CDATA section</td>
</tr>
<tr>
<td>QDomComment</td>
<td>The comment</td>
</tr>
<tr>
<td>QDomProcessingInstruction</td>
<td>The data of the processing instruction</td>
</tr>
<tr>
<td>QDomText</td>
<td>The text</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">All the other subclasses do not have a node value and will return an empty string.</span><br><span class="line">See also setNodeValue() and nodeName().</span><br></pre></td></tr></table></figure>

<p>大概意思是 value必须上面的相关的子类。写一段代码估计就明白了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">QDomText text = doc.createTextNode(&quot;/*this can will empty*/&quot;);</span><br><span class="line">text.setNodeValue(&quot;value&quot;);</span><br><span class="line">QDomNode node.appendChild(text);</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">text = doc.createTextNode(&quot;value&quot;);</span><br><span class="line">child.at(i).appendChild(text);</span><br></pre></td></tr></table></figure>

<p>这时，xml文件中的值发生改变.也就是说setNodeValue 只对上面相关的子类有效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/242024/09/02/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%ADint%E8%BD%ACchar%20%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/242024/09/02/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%ADint%E8%BD%ACchar%20%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">数据传输中int转char 大小端的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：242024-09-02 20:06:00" itemprop="dateCreated datePublished" datetime="242024-09-02T20:06:00+08:00">242024-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-02 20:06:59" itemprop="dateModified" datetime="2024-09-02T20:06:59+08:00">2024-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据传输转化"><a href="#数据传输转化" class="headerlink" title="数据传输转化"></a>数据传输转化</h1><p>在数据传输过程中，经常要将int 型数据转化成char 型数据, 我经常使用的是 union和结构体，具体定义如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> low;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> secLow;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> hight;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> secHight;</span><br><span class="line">    &#125;intBit;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;intCoverChar;</span><br></pre></td></tr></table></figure>

<p>使用的时候 int 转化 char 型数组 小端模式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> data[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">intCoverChar mData;</span><br><span class="line">mData.value =<span class="number">100</span>;<span class="comment">//00 00 00 64</span></span><br><span class="line">data[<span class="number">0</span>] = mData.intBit.low;</span><br><span class="line">data[<span class="number">1</span>] = mData.intBit.secLow;</span><br><span class="line">data[<span class="number">2</span>] = mData.intBit.hight;</span><br><span class="line">data[<span class="number">3</span>] = mData.intBit.secHight;</span><br></pre></td></tr></table></figure>

<p>使用printf 打印</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,data);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,data<span class="number">+1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,data<span class="number">+2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,data<span class="number">+3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,*data);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,*(data<span class="number">+1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,*(data<span class="number">+2</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,*(data<span class="number">+3</span>));</span><br></pre></td></tr></table></figure>

<p>打印出的地址和数据为<br><img src="http://isroot.cn/wp-content/plugins/a3-lazy-load/assets/images/lazy_placeholder.gif"></p>
<p>如果本机是小端模式在内存中结构体的存放数据的地址是从 地位到高位比如上面结构体low的地址为0xbfad1708 seclow即为0xbfad1709 hight的地址为 0xbfad170a secHight的地址为0xbfad170b。数组在内存中的是一块连续的递增的地址，所以如果按照大端的方式往数组里面放为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> data[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">intCoverChar mData;</span><br><span class="line">mData.value =<span class="number">100</span>;<span class="comment">//00 00 00 64</span></span><br><span class="line">data[<span class="number">0</span>] = mData.intBit.hight;</span><br><span class="line">data[<span class="number">1</span>] = mData.intBit.secHight;</span><br><span class="line">data[<span class="number">2</span>] = mData.intBit.low;</span><br><span class="line">data[<span class="number">3</span>] = mData.intBit.secLow;</span><br></pre></td></tr></table></figure>

<p>即 将高位放在数组地位，地位放在数组高位</p>
<p>如果将value值改成 500 按照小端模式的放入 在打印的时候会出现如下的情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fffffff4</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>这是因为一个char 能表示的最大的数为128-1 最高位为符号位，所有要进行扩位 在前面补位补1. 解决这种问题的办法为将数组声明为unsigned char</p>
<p>一个字节是8个二进制位<br>能表示的最大的无符号数为：2^8-1&#x3D;256-1&#x3D;255<br>能表示的最大的有符号数为：2^7-1&#x3D;128-1&#x3D;127</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/242024/09/02/C++%20%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/242024/09/02/C++%20%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">C++ 位操作总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：242024-09-02 19:43:00" itemprop="dateCreated datePublished" datetime="242024-09-02T19:43:00+08:00">242024-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-02 19:44:15" itemprop="dateModified" datetime="2024-09-02T19:44:15+08:00">2024-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>C++：位操作基础篇之位操作全面总结位操作篇共分为基础篇和提高篇。<br>在计算机中所有数据都是以二进制的形式储存的。位运算其实就是直接对在内存中的二进制数据进行操作，因此处理数据的速度非常快。在实际编程中，如果能巧妙运用位操作，完全可以达到四两拨千斤的效果，正因为位操作的这些优点，所以位操作在各大IT公司的笔试面试中一直是个热点问题。因此本文将对位操作进行如下方面总结：<br>– 一． 位操作基础，用一张表描述位操作符的应用规则并详细解释。<br>– 二． 常用位操作小技巧，有判断奇偶、交换两数、变换符号、求绝对值。<br>– 三． 位操作与空间压缩，针对筛素数进行空间压缩。<br>– 四． 位操作的趣味应用，列举了位操作在高低位交换、二进制逆序、二进制中1的个数以及缺失的数字这4种趣味应用。</p>
<h2 id="一-位操作基础"><a href="#一-位操作基础" class="headerlink" title="一 位操作基础"></a>一 位操作基础</h2><p>基本的位操作符有与、或、异或、取反、左移、右移这6种，它们的运算规则如下所示：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>与</td>
<td>两个位都位1，结果才为1</td>
</tr>
<tr>
<td></td>
<td></td>
<td>或 | 两个位都为0，结果才为0</td>
</tr>
<tr>
<td>^</td>
<td>异或</td>
<td>两个位相同为0，相异为1</td>
</tr>
<tr>
<td>~</td>
<td>取反</td>
<td>0变1,1变0</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>各二进位全部左移若干位，高位丢弃，低位补0</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</td>
</tr>
</tbody></table>
<p>注意以下几点：<br>– 1. 在这6种操作符，只有~取反是单目操作符，其它5种都是双目操作符。<br>– 2. 位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。<br>– 3. 对于移位操作，在微软的VC6.0和VS2008编译器都是采取算术称位即算术移位操作，算术移位是相对于逻辑移位，它们在右移操作中都一样，低位补0即可，但在左移中逻辑移位的高位补0而算术移位的高位是补符号位。如下面代码会输出-4和3。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a= <span class="number">-15</span>,b=<span class="number">15</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,a&gt;&gt;<span class="number">2</span>,b&gt;&gt;<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>因为15&#x3D;0000 1111(二进制)，右移二位，最高位由符号位填充将得到0000 0011即3。-15 &#x3D; 1111 0001(二进制)，右移二位，最高位由符号位填充将得到1111 1100即-4（见注1）。</p>
<ul>
<li><ol start="4">
<li>位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。比如要得到像1，3，5，9这些2^i+1的数字。写成 int a &#x3D; 1 &lt;&lt; i + 1;是不对的，程序会先执行i + 1，再执行左移操作。应该写成int a &#x3D; (1 &lt;&lt; i) + 1;</li>
</ol>
</li>
<li><ol start="5">
<li>另外位操作还有一些复合操作符，如&amp;&#x3D;、|&#x3D;、 ^&#x3D;、&lt;&lt;&#x3D;、&gt;&gt;&#x3D;。</li>
</ol>
</li>
</ul>
<h2 id="二-常用位操作小技巧"><a href="#二-常用位操作小技巧" class="headerlink" title="二 常用位操作小技巧"></a>二 常用位操作小技巧</h2><ul>
<li>1.判断奇偶<br>  只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if (a &amp; 1 &#x3D;&#x3D; 0)代替if (a % 2 &#x3D;&#x3D; 0)来判断a是不是偶数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0;i&lt;100;++i)</span><br><span class="line">    if(i&amp;1)</span><br><span class="line">        printf(&quot;%d&quot;,i);</span><br><span class="line">putchar(&#x27;\n&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>2.交换两个数<br>  一般的写法为:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void swap(int &amp;a,int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a!=b)</span><br><span class="line">    &#123;</span><br><span class="line">    int c=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用位操作来实现两个数交换而不使用第三个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void swap(int &amp;a,int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a != b)</span><br><span class="line">    &#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步 a^&#x3D;b 即a&#x3D;(a^b);<br>第二步 b^&#x3D;a 即b&#x3D;b^(a^b)，由于^运算满足交换律，b^(a^b)&#x3D;b^b^a。由于一个数和自己异或的结果为0并且任何数与0异或都会不变的，所以此时b被赋上了a的值。<br>第三步 a^&#x3D;b 就是a&#x3D;a^b，由于前面二步可知a&#x3D;(a^b)，b&#x3D;a，所以a&#x3D;a^b即a&#x3D;(a^b)^a。故a会被赋上b的值。<br>再来个实例说明下以加深印象。int a &#x3D; 13, b &#x3D; 6;<br>a的二进制为 13&#x3D;8+4+1&#x3D;1101(二进制)<br>b的二进制为 6&#x3D;4+2&#x3D;110(二进制)<br>第一步 a^&#x3D;b a &#x3D; 1101 ^ 110 &#x3D; 1011;<br>第二步 b^&#x3D;a b &#x3D; 110 ^ 1011 &#x3D; 1101;即b&#x3D;13<br>第三步 a^&#x3D;b a &#x3D; 1011 ^ 1101 &#x3D; 110;即a&#x3D;5<br>– 3.变换符号<br>变换符号就是正数变成负数，负数变成正数。<br>如对于-11和11，可以通过下面的变换方法将-11变成11<br>1111 0101(二进制) –取反-&gt; 0000 1010(二进制) –加1-&gt; 0000 1011(二进制)<br>同样可以这样的将11变成-11<br>0000 1011(二进制) –取反-&gt; 0000 1010(二进制) –加1-&gt; 1111 0101(二进制)<br>因此变换符号只需要取反后加1即可。完整代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int SignReversal(int a)</span><br><span class="line">&#123;</span><br><span class="line">   return ~a + 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;对整数变换符号 \n\n&quot;);</span><br><span class="line">    int a = 7, b = -12345;</span><br><span class="line">    printf(&quot;%d  %d\n&quot;, SignReversal(a), SignReversal(b));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4.求绝对值<br>  位操作也可以用来求绝对值，对于负数可以通过对其取反后加1来得到正数。对-6可以这样：<br>  1111 1010(二进制) –取反-&gt;0000 0101(二进制) -加1-&gt; 0000 0110(二进制)<br>  来得到6。<br>  因此先移位来取符号位，int i &#x3D; a &gt;&gt; 31;要注意如果a为正数，i等于0，为负数，i等于-1。然后对i进行判断——如果i等于0，直接返回。否之，返回~a+1。完整代码如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int abs(int a)</span><br><span class="line">&#123;</span><br><span class="line">    int i = a&gt;&gt;31;</span><br><span class="line">    return i == 0 ? a:(~a+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在再分析下。对于任何数，与0异或都会保持不变，与-1即0xFFFFFFFF异或就相当于取反。因此，a与i异或后再减i（因为i为0或-1，所以减i即是要么加0要么加1）也可以得到绝对值。所以可以对上面代码优化下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int my_abs(int a)</span><br><span class="line">&#123;</span><br><span class="line">    int i = a &gt;&gt; 31;</span><br><span class="line">    return ((a ^ i) - i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-位操作与空间压缩"><a href="#三-位操作与空间压缩" class="headerlink" title="三.位操作与空间压缩"></a>三.位操作与空间压缩</h2><p>素数法在这里不就详细介绍了，本文着重对筛素数法所使用的素数表进行优化来减小其空间占用。要压缩素数表的空间占用，可以使用位操作。下面是用筛素数法计算100以内的素数示例代码（注2）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;memory.h&gt;</span><br><span class="line">const int MAXN = 100;</span><br><span class="line">bool flag[MAXN];</span><br><span class="line">int primes[MAXN / 3], pi;</span><br><span class="line">//对每个素数，它的倍数必定不是素数。</span><br><span class="line">//有很多重复如flag[10]会在访问flag[2]和flag[5]时各访问一次</span><br><span class="line">void GetPrime_1()</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    pi = 0;</span><br><span class="line">    memset(flag, false, sizeof(flag));</span><br><span class="line">    for (i = 2; i &lt; MAXN; i++)</span><br><span class="line">        if (!flag[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[pi++] = i;</span><br><span class="line">            for (j = i; j &lt; MAXN; j += i)</span><br><span class="line">                flag[j] = true;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">void PrintfArray()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; pi; i++)</span><br><span class="line">        printf(&quot;%d &quot;, primes[i]);</span><br><span class="line">    putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;用筛素数法求100以内的素数\n&quot;);</span><br><span class="line">    GetPrime_1();</span><br><span class="line">    PrintfArray();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序是用bool数组来作标记的，bool型数据占1个字节（8位），因此用位操作来压缩下空间占用将会使空间的占用减少八分之一。<br>下面考虑下如何在数组中对指定位置置1，先考虑如何对一个整数在指定位置上置1。对于一个整数可以通过将1向左移位后与其相或来达到在指定位上置1的效果，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在一个数指定位上置1</span><br><span class="line">int j = 0;</span><br><span class="line">j |=  1 &lt;&lt; 10;</span><br><span class="line">printf(&quot;%d\n&quot;, j);</span><br></pre></td></tr></table></figure>

<p>同样，可以1向左移位后与原数相与来判断指定位上是0还是1（也可以将原数右移若干位再与1相与）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//判断指定位上是0还是1</span><br><span class="line">int j = 1 &lt;&lt; 10;</span><br><span class="line">if ((j &amp; (1 &lt;&lt; 10)) != 0)</span><br><span class="line">    printf(&quot;指定位上为1&quot;);</span><br><span class="line">else</span><br><span class="line">    printf(&quot;指定位上为0&quot;);</span><br></pre></td></tr></table></figure>

<p>扩展到数组上，我们可以采用这种方法，因为数组在内存上也是连续分配的一段空间，完全可以“认为”是一个很长的整数。先写一份测试代码，看看如何在数组中使用位操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;     对数组中指定位置上置位和判断该位\n&quot;);</span><br><span class="line">    //在数组中在指定的位置上写1</span><br><span class="line">    int b[5] = &#123;0&#125;;</span><br><span class="line">    int i;</span><br><span class="line">    //在第i个位置上写1</span><br><span class="line">    for (i = 0; i &lt; 40; i += 3)</span><br><span class="line">        b[i / 32] |= (1 &lt;&lt; (i % 32));</span><br><span class="line">    //输出整个bitset</span><br><span class="line">    for (i = 0; i &lt; 40; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((b[i / 32] &gt;&gt; (i % 32)) &amp; 1)</span><br><span class="line">            putchar(&#x27;1&#x27;);</span><br><span class="line">        else</span><br><span class="line">            putchar(&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将上面筛素数方法改成使用位操作压缩后的筛素数方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;memory.h&gt;</span><br><span class="line">const int MAXN = 100;</span><br><span class="line">int flag[MAXN / 32];</span><br><span class="line">int primes[MAXN / 3], pi;</span><br><span class="line">void GetPrime_1()</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    pi = 0;</span><br><span class="line">    memset(flag, 0, sizeof(flag));</span><br><span class="line">    for (i = 2; i &lt; MAXN; i++)</span><br><span class="line">        if (!((flag[i / 32] &gt;&gt; (i % 32)) &amp; 1))</span><br><span class="line">        &#123;</span><br><span class="line">            primes[pi++] = i;</span><br><span class="line">            for (j = i; j &lt; MAXN; j += i)</span><br><span class="line">                flag[j / 32] |= (1 &lt;&lt; (j % 32));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">void PrintfArray()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; pi; i++)</span><br><span class="line">        printf(&quot;%d &quot;, primes[i]);</span><br><span class="line">    putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;用位操作压缩后筛素数法求100以内的素数\n&quot;);</span><br><span class="line">    GetPrime_1();</span><br><span class="line">    PrintfArray();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-位操作趣味应用"><a href="#四-位操作趣味应用" class="headerlink" title="四 位操作趣味应用"></a>四 位操作趣味应用</h2><ul>
<li>1． 高低位交换<br>  给出一个16位的无符号整数。称这个二进制数的前8位为“高位”，后8位为“低位”。现在写一程序将它的高低位交换。例如，数34520用二进制表示为：<br>  10000110 11011000<br>  将它的高低位进行交换，我们得到了一个新的二进制数：<br>  11011000 10000110<br>  它即是十进制的55430。<br>  这个问题用位操作解决起来非常方便，设x&#x3D;34520&#x3D;10000110 11011000(二进制) 由于x为无符号数，右移时会执行逻辑右移即高位补0，因此x右移8位将得到0000000010000110。而x左移8位将得到11011000 00000000。可以发现只要将x&gt;&gt;8与x&lt;&lt;8这两个数相与就可以得到11011000 10000110。用代码实现非常简洁：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void PrintfBinary(T a)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = sizeof(a) * 8 - 1; i &gt;= 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((a &gt;&gt; i) &amp; 1)</span><br><span class="line">            putchar(&#x27;1&#x27;);</span><br><span class="line">        else</span><br><span class="line">            putchar(&#x27;0&#x27;);</span><br><span class="line">        if (i == 8)</span><br><span class="line">            putchar(&#x27; &#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;高低位交换 \n&quot;);</span><br><span class="line">    printf(&quot;交换前:    &quot;);</span><br><span class="line">    unsigned short a = 3344520;</span><br><span class="line">    PrintfBinary(a);</span><br><span class="line">    printf(&quot;交换后:    &quot;);</span><br><span class="line">    a = (a &gt;&gt; 8) | (a &lt;&lt; 8);</span><br><span class="line">    PrintfBinary(a);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2.二进制逆序<br>  我们知道如何对字符串求逆序，现在要求计算二进制的逆序，如数34520用二进制表示为：<br>  10000110 11011000<br>  将它逆序，我们得到了一个新的二进制数：<br>  00011011 01100001<br>  它即是十进制的7009。<br>  回顾下字符串的逆序，可以从字符串的首尾开始，依次交换两端的数据。在二进制逆序我们也可以用这种方法，但运用位操作的高低位交换来处理二进制逆序将会得到更简洁的方法。类似于归并排序的分组处理，可以通过下面4步得到16位数据的二进制逆序：<br>  第一步：每2位为一组，组内高低位交换<br>  10 00 01 10 11 01 10 00<br>  –&gt;01 00 10 01 11 10 01 00<br>  第二步：每4位为一组，组内高低位交换<br>  0100 1001 1110 0100<br>  –&gt;0001 0110 1011 0001<br>  第三步：每8位为一组，组内高低位交换<br>  00010110 10110001<br>  –&gt;01100001 00011011<br>  第四步：每16位为一组，组内高低位交换<br>  01100001 00011011<br>  –&gt;00011011 01100001<br>  对第一步，可以依次取出每2位作一组，再组内高低位交换，这样有点麻烦，下面介绍一种非常有技巧的方法。先分别取10000110 11011000的奇数位和偶数位，空位以下划线表示。<br>  原 数 10000110 11011000<br>  奇数位 1_0_0_1_ 1_0_1_0_<br>  偶数位 _0_0_1_0 _1_1_0_0<br>  将下划线用0填充，可得<br>  原 数 10000110 11011000<br>  奇数位 10000010 10001000<br>  偶数位 00000100 01010000<br>  再将奇数位右移一位，偶数位左移一位，此时将这两个数据相与即可以达到奇偶位上数据交换的效果了。<br>  原 数 10000110 11011000<br>  奇数位右移 01000011 01101100<br>  偶数位左移 0000100 010100000<br>  相与得到 01001000 11100100<br>  可以看出，结果完全达到了奇偶位的数据交换，再来考虑代码的实现——<br>  取x的奇数位并将偶数位用0填充用代码实现就是x &amp; 0xAAAA<br>  取x的偶数位并将奇数位用0填充用代码实现就是x &amp; 0x5555<br>  因此，第一步就用代码实现就是：<br>  x &#x3D; ((x &amp; 0xAAAA) &gt;&gt; 1) | ((x &amp; 0x5555) &lt;&lt; 1);</li>
</ul>
<p>完整代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void PrintfBinary(T a)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = sizeof(a) * 8 - 1; i &gt;= 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((a &gt;&gt; i) &amp; 1)</span><br><span class="line">            putchar(&#x27;1&#x27;);</span><br><span class="line">        else</span><br><span class="line">            putchar(&#x27;0&#x27;);</span><br><span class="line">        if (i == 8)</span><br><span class="line">            putchar(&#x27; &#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;二进制逆序 \n&quot;);</span><br><span class="line">    printf(&quot;逆序前:    &quot;);</span><br><span class="line">    unsigned short a = 34520;</span><br><span class="line">    PrintfBinary(a);</span><br><span class="line">    printf(&quot;逆序后:    &quot;);</span><br><span class="line">    a = ((a &amp; 0xAAAA) &gt;&gt; 1) | ((a &amp; 0x5555) &lt;&lt; 1);</span><br><span class="line">    a = ((a &amp; 0xCCCC) &gt;&gt; 2) | ((a &amp; 0x3333) &lt;&lt; 2);</span><br><span class="line">    a = ((a &amp; 0xF0F0) &gt;&gt; 4) | ((a &amp; 0x0F0F) &lt;&lt; 4);</span><br><span class="line">    a = ((a &amp; 0xFF00) &gt;&gt; 8) | ((a &amp; 0x00FF) &lt;&lt; 8);</span><br><span class="line">    PrintfBinary(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.二进制中的个数<br>  统计二进制中1的个数可以直接移位再判断，当然像《编程之美》书中用循环移位计数或先打一个表再计算都可以。本文详细讲解一种高效的方法。以34520为例，可以通过下面四步来计算其二进制中1的个数二进制中1的个数。<br>  第一步：每2位为一组，组内高低位相加<br>  10 00 01 10 11 01 10 00<br>  –&gt;01 00 01 01 10 01 01 00<br>  第二步：每4位为一组，组内高低位相加<br>  0100 0101 1001 0100<br>  –&gt;0001 0010 0011 0001<br>  第三步：每8位为一组，组内高低位相加<br>  00010010 00110001<br>  –&gt;00000011 00000100<br>  第四步：每16位为一组，组内高低位相加<br>  00000011 00000100<br>  –&gt;00000000 00000111<br>  这样最后得到的00000000 00000111即7即34520二进制中1的个数。类似上文中对二进制逆序的做法不难实现第一步的代码：<br>  x &#x3D; ((x &amp; 0xAAAA) &gt;&gt; 1) + (x &amp; 0x5555);</li>
</ul>
<p>完整代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void PrintfBinary(T a)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = sizeof(a) * 8 - 1; i &gt;= 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((a &gt;&gt; i) &amp; 1)</span><br><span class="line">            putchar(&#x27;1&#x27;);</span><br><span class="line">        else</span><br><span class="line">            putchar(&#x27;0&#x27;);</span><br><span class="line">        if (i == 8)</span><br><span class="line">            putchar(&#x27; &#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;二进制中1的个数\n&quot;);</span><br><span class="line">    unsigned short a = 34520;</span><br><span class="line">    printf(&quot;原数    %6d的二进制为:  &quot;, a);</span><br><span class="line">    PrintfBinary(a);</span><br><span class="line">    a = ((a &amp; 0xAAAA) &gt;&gt; 1) + (a &amp; 0x5555);</span><br><span class="line">    a = ((a &amp; 0xCCCC) &gt;&gt; 2) + (a &amp; 0x3333);</span><br><span class="line">    a = ((a &amp; 0xF0F0) &gt;&gt; 4) + (a &amp; 0x0F0F);</span><br><span class="line">    a = ((a &amp; 0xFF00) &gt;&gt; 8) + (a &amp; 0x00FF);</span><br><span class="line">    printf(&quot;计算结果%6d的二进制为:  &quot;, a);</span><br><span class="line">    PrintfBinary(a);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4.将数据位某位置1 或者置 0</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define setbit(x,y) x|=(1&lt;&lt;y)         //将X的第Y位置1</span><br><span class="line">#define clrbit(x,y) x&amp;=~(1&lt;&lt;y)            //将X的第Y位清0</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">       unsigned short Nun = 0;</span><br><span class="line">       setbit(Nun,15);</span><br><span class="line">       setbit(Nun,14);</span><br><span class="line">       //clrbit(Nun,15);</span><br><span class="line">       if (Nun&gt;&gt;14&amp;1)   //判断第十四位是否为一</span><br><span class="line">       &#123;</span><br><span class="line">              cout&lt;&lt;&quot;14位为1&quot;&lt;&lt;endl;</span><br><span class="line">       &#125;</span><br><span class="line">       if (Nun&gt;&gt;15&amp;1)  //判断第十五位是否为一</span><br><span class="line">       &#123;</span><br><span class="line">              cout&lt;&lt;&quot;15位为1&quot;&lt;&lt;endl;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/242024/09/02/Qt%E4%B8%AD%E7%9A%84%20pro%20%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/242024/09/02/Qt%E4%B8%AD%E7%9A%84%20pro%20%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">Qt中的 pro 文件介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：242024-09-02 18:54:00" itemprop="dateCreated datePublished" datetime="242024-09-02T18:54:00+08:00">242024-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-02 19:38:33" itemprop="dateModified" datetime="2024-09-02T19:38:33+08:00">2024-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Qt在嵌入式开发中，一般是在PC端环境中编写程序，然后调试，最后移植到开发中调试，如果使用第三方库的时候这就涉及到在PC端和ARM两个不同的环境中要使用不同的库，为了方便编译在.pro文件中设置了一个变量。具体使用如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#定义一个变量</span><br><span class="line">PLATFORM=Arm</span><br><span class="line">#PLATFORM=Linux</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在这里判断变量</span></span><br><span class="line"><span class="built_in">isEqual</span>(PLATFORM,Arm)&#123;<span class="comment">//在pro左大括号必须在根据括号后面，否则函数不起作用</span></span><br><span class="line">    <span class="meta">#dosomething</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">isEqual</span>(PLATFORM,Linxu)&#123;</span><br><span class="line">    <span class="meta">#dosomething</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当我们选择不通的编译器的时候，只需要把不同的值放开就可以了。</p>
<h1 id="pro文件整理"><a href="#pro文件整理" class="headerlink" title=".pro文件整理"></a>.pro文件整理</h1><ul>
<li><h1 id="注释，从”-”开始，到这一行结束"><a href="#注释，从”-”开始，到这一行结束" class="headerlink" title="注释，从”#”开始，到这一行结束"></a>注释，从”#”开始，到这一行结束</h1></li>
<li>SOURCE</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#指定源文件</span><br><span class="line">SOURCE =.*cpp</span><br><span class="line">#对于多个源文件，可以用空格分开</span><br><span class="line">SOURCE =1.cpp 2.cpp 3.cpp</span><br><span class="line">#或者每个文件可以单独占一行，用 \ 换行</span><br><span class="line">SOURCE = 1.cpp \</span><br><span class="line">           2.cpp</span><br></pre></td></tr></table></figure>

<ul>
<li>HEADERS 指定头文件 <code>HEADERS+=1.h</code></li>
<li>CONFIG 指定配置信息 <code>CONFIG+=qt warn_on release</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">编译器标志：</span><br><span class="line">release  应用程序将以release模式编译，如果“debug”被指定，它将被忽略</span><br><span class="line">debug    应用程序以debug模式编译</span><br><span class="line">warn_on  编译器会输出尽可能多的警告信息，如果&quot;warn_off&quot;被指定，它将被忽略</span><br><span class="line">qt       应用程式是一个qt应用程序，并且qt库将被链接</span><br><span class="line">thread   应用程序是一个多线程应用程序</span><br><span class="line">x11      应用程序是一个x11应用程序或者库</span><br><span class="line">windows  只用于app模板：应用程序是一个windows下的窗口应用程序</span><br><span class="line">console  只用于app模板：应用程序是一个windows下控制台应用程序</span><br><span class="line">dll      只用于lib 模板：库是一个共享库</span><br><span class="line">staticlib 只用于lib模板：库是一个静态库</span><br><span class="line">plugin   只用于lib模板，库是一个插件，这将会使dll选项生效</span><br></pre></td></tr></table></figure>

<ul>
<li>TARGET 指定目标文件名，如果不设置该项目，目标名会设置成和项目名称一样的名字<code>TARGET=filename</code></li>
<li>INTERFACES 添加界面ui文件 <code>INTERFACES= filename.ui</code></li>
<li>TEMPLATE 模块设置 <code>TEMPLATE=app</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app(生成应用程序，默认)</span><br><span class="line">subdirs(生成makefile文件编译subdirs指定的子文件夹)</span><br><span class="line">lib(生成库文件)</span><br></pre></td></tr></table></figure>

<ul>
<li>DESTDIR 指定生成的应用程序的放置目录 <code>DESTDIR+= ../bin</code></li>
<li>UI_DIR 指定uic命令将.ui文件转化成ui_*.h文件的存放目录 <code>UI_DIR+=froms</code></li>
<li>RCC_DIR 指定rcc命令将.qrc文件转化成qrc_*.h 文件存放目录 <code>RCC_DIR+=../temp</code></li>
<li>MOC_DIR 指定moc命令将Q_OBJECT的头文件转化成标准.h文件存放目录 <code>MOC_DIR+=../temp</code></li>
<li>OBJECTS_DIR 指定目标文件的存放目录 <code>OBJECTS_DIR+=../temp</code></li>
<li>DEPENDPATH 程序编译时依赖的相关路径 <code>DEPENDPATH+=.forms include qrc sources</code></li>
<li>INCLUDEPATH 头文件的目录 <code>INCLUDEPATH+=./</code></li>
<li>CODECFORSRC 源文件编译方式 <code>CODECFORSRC = GBK</code></li>
<li>FORMS 工程中ui文件存放目录 <code>FORMS+=.</code></li>
<li>RESOURCES 工程中包含的资源文件 <code>RESOURCES +=qrc/painter.qrc</code></li>
<li>win32{…} unix{…} 平台相关性处理 <code>win32 &#123;SOURCES += hello_win.cpp&#125;</code></li>
<li>LANGUAGE 语言 <code>LANGUAGE = C++</code></li>
<li>QT 加入库模块 <code>QT += xml</code></li>
<li>exists !exists 如果一个文件不存在，停止 qmake <code>!exists( main.cpp ) &#123;error( &quot;No main.cpp file found&quot;)&#125;</code></li>
<li>LIBS 加入第三方库 <code>LIBS += -L folderPath</code> 是引入lib文件的目录 <code>LIBS += -lLibName 是引入库</code></li>
</ul>
<h1 id="更多其他变量："><a href="#更多其他变量：" class="headerlink" title="更多其他变量："></a>更多其他变量：</h1><ul>
<li>app ‐ 建立一个应用程序的 makefile。这是默认值，所以如果模板没有被指定，这个将被使<br>  用。</li>
<li>lib ‐ 建立一个库的 makefile。</li>
<li>vcapp ‐ 建立一个应用程序的 Visual Studio 项目文件。</li>
<li>vclib ‐ 建立一个库的 Visual Studio 项目文件。</li>
<li>subdirs ‐ 这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成<br>  makefile 并且为它调用 make 的 makefile。</li>
<li>“app”模板<br>  “app”模板告诉 qmake 为建立一个应用程序生成一个 makefile。当使用这个模板时，下面<br>  这些 qmake 系统变量是被承认的。你应该在你的.pro 文件中使用它们来为你的应用程序指<br>  定特定信息。</li>
<li>HEADERS ‐ 应用程序中的所有头文件的列表。</li>
<li>SOURCES ‐ 应用程序中的所有源文件的列表。</li>
<li>FORMS ‐ 应用程序中的所有.ui 文件（由 Qt 设计器生成）的列表。</li>
<li>LEXSOURCES ‐ 应用程序中的所有 lex 源文件的列表。</li>
<li>YACCSOURCES ‐ 应用程序中的所有 yacc 源文件的列表。</li>
<li>TARGET ‐ 可执行应用程序的名称。默认值为项目文件的名称。（如果需要扩展名，会被自动<br>  加上。）</li>
<li>DESTDIR ‐ 放置可执行程序目标的目录。</li>
<li>DEFINES ‐ 应用程序所需的额外的预处理程序定义的列表。</li>
<li>INCLUDEPATH ‐ 应用程序所需的额外的包含路径的列表。</li>
<li>DEPENDPATH ‐ 应用程序所依赖的搜索路径。</li>
<li>VPATH ‐ 寻找补充文件的搜索路径。</li>
<li>DEF_FILE ‐ 只有 Windows 需要：应用程序所要连接的.def 文件。</li>
<li>RC_FILE ‐ 只有 Windows 需要：应用程序的资源文件。</li>
<li>RES_FILE ‐ 只有 Windows 需要：应用程序所要连接的资源文件。</li>
<li>CONFIG 变量<br>  配置变量指定了编译器所要使用的选项和所需要被连接的库。配置变量中可以添加任何东<br>  西，但只有下面这些选项可以被 qmake 识别。<br>  下面这些选项控制着使用哪些编译器标志：<br>  release ‐ 应用程序将以 release 模式连编。如果“debug”被指定，它将被忽略。<br>  debug ‐ 应用程序将以 debug 模式连编。<br>  warn_on ‐ 编译器会输出尽可能多的警告信息。如果“warn_off”被指定，它将被忽略。<br>  warn_off ‐ 编译器会输出尽可能少的警告信息。<br>  下面这些选项定义了所要连编的库&#x2F;应用程序的类型：<br>  qt ‐ 应用程序是一个 Qt 应用程序，并且 Qt 库将会被连接。<br>  thread ‐ 应用程序是一个多线程应用程序。<br>  x11 ‐ 应用程序是一个 X11 应用程序或库。<br>  windows ‐ 只用于“app”模板：应用程序是一个 Windows 下的窗口应用程序。<br>  console ‐ 只用于“app”模板：应用程序是一个 Windows 下的控制台应用程序。<br>  dll ‐ 只用于“lib”模板：库是一个共享库（dll）。<br>  staticlib ‐ 只用于“lib”模板：库是一个静态库。<br>  plugin ‐ 只用于“lib”模板：库是一个插件，这将会使 dll 选项生效。<br>  例如，如果你的应用程序使用 Qt 库，并且你想把它连编为一个可调试的多线程的应用程序，<br>  你的项目文件应该会有下面这行：<br>  CONFIG +&#x3D; qt thread debug 注意，你必须使用“+&#x3D;”，不要使用“&#x3D;”，否则 qmake 就不<br>  能正确使用连编 Qt 的设置了，比如没法获得所编译的 Qt 库的类型了。</li>
<li>qmake 高级概念<br>  操作符<br>  “&#x3D;”操作符 分配一个值给一个变量<br>  “+&#x3D;”操作符 向一个变量的值的列表中添加一个值<br>  “‐&#x3D;”操作符 从一个变量的值的列表中移去一个值<br>  “*&#x3D;”操作符 仅仅在一个值不存在于一个变量的值的列表中的时候，把它添加进去<br>  “~&#x3D;”操作符 替换任何与指定的值的正则表达式匹配的任何值 DEFINES ~&#x3D;<br>  s&#x2F;QT_[DT].+&#x2F;QT</li>
<li>作用域    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">win32:thread &#123;  </span><br><span class="line">DEFINES += QT_THREAD_SUPPORT &#125; else:debug &#123; DEFINES +=  </span><br><span class="line">QT_NOTHREAD_DEBUG &#125; else &#123; warning(“Unknown configuration”) &#125; &#125;</span><br></pre></td></tr></table></figure></li>
<li>变量<ul>
<li>到目前为止我们遇到的变量都是系统变量，比如 DEFINES、 SOURCES 和 HEADERS。你也可以<br>  为你自己创建自己的变量，这样你就可以在作用域中使用它们了。创建自己的变量很容易，<br>  只要命名它并且分配一些东西给它。比如：<br>  MY_VARIABLE &#x3D; value 你也可以通过在其它任何一个变量的变量名前加 <code>$$</code>  来把这个变量<br>  的值分配给当前的变量。例如: <code>MY_DEFINES = $$DEFINESMY_DEFINES = $$&#123;DEFINES&#125;</code><br>  第二种方法允许你把一个变量和其它变量连接起来，而不用使用空格。 qmake 将允许一个变<br>  量包含任何东西（包括$(VALUE)，可以直接在 makefile 中直接放置，并且允许它适当地扩张，<br>  通常是一个环境变量）。无论如何，如果你需要立即设置一个环境变量，然后你就可以使用<br>  $$()方法。比如：<br>  MY_DEFINES &#x3D; $$(ENV_DEFINES)这将会设置 MY_DEFINES 为环境变量 ENV_DEFINES 传递<br>  给.pro 文件地值。另外你可以在替换的变量里调用内置函数。这些函数（不会和下一节中列<br>  举的测试函数混淆）列出如下：<br>  join( variablename, glue, before, after )<br>  这将会在 variablename 的各个值中间加入 glue。如果这个变量的值为非空，那么就会在值的<br>  前面加一个前缀 before 和一个后缀 after。只有 variablename 是必须的字段，其它默认情况<br>  下为空串。如果你需要在 glue、 before 或者 after 中使用空格的话，你必须提供它们。<br>  member( variablename, position )<br>  这将会放置 variablename 的列表中的 position 位置的值。如果 variablename 不够长，这将会<br>  返回一个空串。 variablename 是唯一必须的字段，如果没有指定位置，则默认为列表中的第<br>  一个值。<br>  find( variablename, substr )<br>  这将会放置 variablename 中所有匹配 substr 的值。 substr 也可以是正则表达式，而因此将被匹配。<br>  MY_VAR &#x3D; one two three four MY_VAR2 &#x3D; $$join(MY_VAR, ” ‐L”, ‐L) ‐Lfive MY_VAR3&#x3D; $$member(MY_VAR, 2) $$find(MY_VAR, t.*)<br>  MY_VAR2 将会包含“‐Lone ‐Ltwo ‐Lthree ‐Lfour<br>  ‐Lfive”，并且 MYVAR3 将会包含“three two three”。<br>  system( program_and_args )<br>  这将会返回程序执行在标准输出&#x2F;标准错误输出的内容，并且正像平时所期待地分析它。比<br>  如你可以使用这个来询问有关平台的信息。<br>  UNAME &#x3D; $$system(uname ‐s) contains( UNAME, [lL]inux ):message( This looks like Linux ($$UNAME) to me )测试函数<br>  qmake 提供了可以简单执行，但强大测试的内置函数。这些测试也可以用在作用域中（就像<br>  上面一样），在一些情况下，忽略它的测试值，它自己使用测试函数是很有用的。<br>  contains( variablename, value )<br>  如果 value 存在于一个被叫做 variablename 的变量的值的列表中，那么这个作用域中的设置<br>  将会被处理。例如：<br>  contains( CONFIG, thread ) { DEFINES +&#x3D; QT_THREAD_SUPPORT }如果 thread<br>  存在于 CONFIG 变量的值的列表中时，那么 QT_THREAD_SUPPORT 将会被加入到 DEFINES 变<br>  量的值的列表中。<br>  count( variablename, number )<br>  如果 number 与一个被叫做 variablename 的变量的值的数量一致，那么这个作用域中的设置<br>  将会被处理。例如：<br>  count( DEFINES, 5 ) { CONFIG +&#x3D; debug }error( string )<br>  这个函数输出所给定的字符串，然后会使 qmake 退出。例如：<br>  error( “An error has occured” )文本“An error has occured”将会被显示在控制台上并且<br>  qmake 将会退出。<br>  exists( filename )<br>  如果指定文件存在，那么这个作用域中的设置将会被处理。例如：<br>  exists( &#x2F;local&#x2F;qt&#x2F;qmake&#x2F;main.cpp ) { SOURCES +&#x3D; main.cpp } 如 果<br>  &#x2F;local&#x2F;qt&#x2F;qmake&#x2F;main.cpp 存在，那么 main.cpp 将会被添加到源文件列表中。<br>  注意可以不用考虑平台使用“&#x2F;”作为目录的分隔符。<br>  include( filename )<br>  项目文件在这一点时包含这个文件名的内容，所以指定文件中的任何设置都将会被处理。例<br>  如：<br>  include( myotherapp.pro )myotherapp.pro 项目文件中的任何设置现在都会被处理。<br>  isEmpty( variablename )<br>  这和使用 count( variablename, 0 )是一样的。如果叫做 variablename 的变量没有任何元素，<br>  那么这个作用域中的设置将会被处理。例如：<br>  isEmpty( CONFIG ) { CONFIG +&#x3D; qt warn_on debug }message( string )<br>  这个函数只是简单地在控制台上输出消息。<br>  message( “This is a message” )文本“This is a message”被输出到控制台上并且对于项目<br>  67<br>  文件的处理将会继续进行。<br>  system( command )<br>  特定指令被执行并且如果它返回一个 1 的退出值，那么这个作用域中的设置将会被处理。例<br>  如：<br>  system( ls &#x2F;bin ) { SOURCES +&#x3D; bin&#x2F;main.cpp HEADERS +&#x3D; bin&#x2F;main.h }<br>  所以如果命令 ls &#x2F;bin 返回 1，那么 bin&#x2F;main.cpp 将被添加到源文件列表中并且 bin&#x2F;main.h 将<br>  被添加到头文件列表中。<br>  infile( filename, var, val )<br>  如果 filename 文件（当它被 qmake 自己解析时）包含一个值为 val 的变量 var，那么这个函<br>  数将会返回成功。你也可以不传递第三个参数（val），这时函数将只测试文件中是否分配有<br>  这样一个变量 var。</li>
</ul>
</li>
</ul>
<h1 id="以下为我的一个项目举例"><a href="#以下为我的一个项目举例" class="headerlink" title="以下为我的一个项目举例"></a>以下为我的一个项目举例</h1><p>项目目标：为一个库文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATE = lib # 编译项目文件所需头文件的路径</span><br><span class="line">INCLUDEPATH += ../common # 目标文件路径</span><br><span class="line">DESTDIR=../lib # 条件依赖： Unix 平台上 定义本想目的 UI 目录， MOC 目录， 目的目</span><br><span class="line">录</span><br><span class="line">unix &#123; UI_DIR = ../.ui MOC_DIR = ../.moc OBJECTS_DIR = ../.obj&#125; # 本 项 目 配 置 ：</span><br><span class="line">CONFIG += qt warn_on release thread </span><br><span class="line"># Input 头文件，源文件 </span><br><span class="line">HEADERS +=</span><br><span class="line">COMControllerThread.h \ </span><br><span class="line">DecodeSMS.h \ </span><br><span class="line">monitor_common.h \</span><br><span class="line">monitor_interface.h \ </span><br><span class="line">MonitorThread.h \ </span><br><span class="line">UserEvent.h \</span><br><span class="line">MyCOM.h \ </span><br><span class="line">MySMS.h \ </span><br><span class="line">MyTagHandle.h \</span><br><span class="line">SMSParseThread.h \ </span><br><span class="line">tag_dict.h</span><br><span class="line">SOURCES += COMControllerThread.cpp \</span><br><span class="line">DecodeSMS.cpp \ </span><br><span class="line">monitor_common.cpp \</span><br><span class="line">monitor_interface.cpp \</span><br><span class="line">MonitorThread.cpp \</span><br><span class="line">MyCOM.cpp \</span><br><span class="line">MySMS.cpp \</span><br><span class="line">MyTagHandle.cpp \</span><br><span class="line">SMSParseThread.cpp \</span><br><span class="line">tag_dict.cpp </span><br></pre></td></tr></table></figure>

<p>注： qmake<br>‐project 可以生成 pro 文件（可以根据项目需要，编辑改文件）<br>qmake 可以生成 Makefile 文件<br>make 编译<br>使用 qmake ‐project 时，会把本目录及其子目录内所有.cpp .h 文件加入到项目输入文件中，<br>使用是注意移去其他无用的文件。<br>qmake 生成的 Makefile 文件，可以根据需要做相应修改</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/242024/09/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/242024/09/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/" class="post-title-link" itemprop="url">树莓派远程桌面</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：242024-09-02 18:51:00" itemprop="dateCreated datePublished" datetime="242024-09-02T18:51:00+08:00">242024-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-02 18:53:04" itemprop="dateModified" datetime="2024-09-02T18:53:04+08:00">2024-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近项目中要使用树莓派，以前自己玩过树莓派，但没做记录，此次趁着项目把使用过程中的问题做个详细的记录<br>– 远程桌面<br>只需要在raspbian下面安装一个服务xdrp即可。输入如下命令安装：<br><code>sudo apt-get install xrdp</code><br>然后就Ok了</p>
<p>安装完成后使用windows 远程桌面连接会出现报错 error – problem connecting，问题根源在于tightvnc，出现问题的版本跟X字体有冲突，导致连接Xserver出错。<br><code>sudo apt-get purge tightvnc xrdp</code><br><code>sudo apt-get install tightvncserver xrdp</code></p>
<p>最后启动 xrdp 服务，sudo &#x2F;etc&#x2F;init.d&#x2F;xrdp restart，此时会启用相应端口，配置方面默认即可。<br>通过命令：netstat -tnl<br>查看 3350 3389 5910 这三个端口处于LISTEN，一般就没问题了。<br>dpkg -L + 软件包的名字，可以知道这个软件包包含了哪些文件。</p>
<h1 id="翻转屏幕"><a href="#翻转屏幕" class="headerlink" title="翻转屏幕"></a>翻转屏幕</h1><p>1、切换为root</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure>

<p>2、编辑&#x2F;boot&#x2F;config.txt，根据想旋转的角度<br>对于触摸屏添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lcd_rotate = 0 //不旋转</span><br><span class="line">lcd_rotate = 1 //旋转90度</span><br><span class="line">lcd_rotate = 2 //旋转180</span><br><span class="line">lcd_rotate = 3 //旋转270</span><br></pre></td></tr></table></figure>

<p>对于HDMI显示输出，添加：</p>
<p>如果是只是想旋转HDMI输出显示的角度（不用触摸屏）<br>则可以添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display_rotate = 0</span><br><span class="line">display_rotate = 1</span><br><span class="line">display_rotate = 2</span><br><span class="line">display_rotate = 3</span><br></pre></td></tr></table></figure>

<p>3、reboot</p>
<p>重启后，触摸屏驱动和显示都会旋转。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/242024/08/21/linux%20%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/242024/08/21/linux%20%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81%E5%BA%93/" class="post-title-link" itemprop="url">linux 配置动态库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：242024-08-21 13:43:00" itemprop="dateCreated datePublished" datetime="242024-08-21T13:43:00+08:00">242024-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-21 13:47:46" itemprop="dateModified" datetime="2024-08-21T13:47:46+08:00">2024-08-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 Linux 系统中，程序运行时链接的库文件是通过动态链接器（dynamic linker）来处理的。我们可以使用一些方法来指定程序在运行时链接到特定的库文件。</p>
<p>以下是几种方法来实现这一目标：</p>
<h3 id="1-使用-LD-LIBRARY-PATH-环境变量"><a href="#1-使用-LD-LIBRARY-PATH-环境变量" class="headerlink" title="1. 使用 LD_LIBRARY_PATH 环境变量"></a>1. 使用 <code>LD_LIBRARY_PATH</code> 环境变量</h3><p><code>LD_LIBRARY_PATH</code> 是一个环境变量，它可以告诉动态链接器在指定的路径中查找库文件。当程序运行时，动态链接器会优先搜索这个路径中的库文件，而不是系统默认的路径。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>假设你有一个自定义的库文件放在 <code>/custom/lib</code> 目录下，你可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/custom/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">./your_program</span><br></pre></td></tr></table></figure>

<p>这样，程序会首先从 <code>/custom/lib</code> 目录中查找库文件。</p>
<h3 id="2-使用-ldd-命令查看链接的库文件"><a href="#2-使用-ldd-命令查看链接的库文件" class="headerlink" title="2. 使用 ldd 命令查看链接的库文件"></a>2. 使用 <code>ldd</code> 命令查看链接的库文件</h3><p>在执行程序之前，您可以使用 <code>ldd</code> 命令来查看该程序将会链接的库文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd ./your_program</span><br></pre></td></tr></table></figure>

<p>该命令会列出该程序运行时需要的所有动态链接库及其路径。</p>
<h3 id="3-使用-LD-PRELOAD-强制加载库文件"><a href="#3-使用-LD-PRELOAD-强制加载库文件" class="headerlink" title="3. 使用 LD_PRELOAD 强制加载库文件"></a>3. 使用 <code>LD_PRELOAD</code> 强制加载库文件</h3><p><code>LD_PRELOAD</code> 是一个环境变量，它允许你在程序运行时强制加载指定的共享库。这可以用于覆盖某些库函数的实现。</p>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><p>假设你想让程序使用一个特定版本的库，你可以这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_PRELOAD=/path/to/your/library.so</span><br><span class="line">./your_program</span><br></pre></td></tr></table></figure>

<p>这样，动态链接器会优先加载 <code>/path/to/your/library.so</code> 中的符号，即使程序默认链接了其他库。</p>
<h3 id="4-在编译时指定链接路径（如果可以重新编译）"><a href="#4-在编译时指定链接路径（如果可以重新编译）" class="headerlink" title="4. 在编译时指定链接路径（如果可以重新编译）"></a>4. 在编译时指定链接路径（如果可以重新编译）</h3><p>在编译程序时，你可以使用编译器选项指定库文件的搜索路径，这样在运行时可以自动找到正确的库文件。</p>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><p>假设你正在编译一个 C 程序，可以使用 <code>-L</code> 选项指定库文件的路径，使用 <code>-l</code> 选项指定库的名称。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o your_program your_program.c -L/custom/lib -lyourlib</span><br></pre></td></tr></table></figure>

<p>这个命令会告诉编译器在 <code>/custom/lib</code> 目录下寻找 <code>libyourlib.so</code>。</p>
<h3 id="5-修改程序的-rpath-或-runpath"><a href="#5-修改程序的-rpath-或-runpath" class="headerlink" title="5. 修改程序的 rpath 或 runpath"></a>5. 修改程序的 <code>rpath</code> 或 <code>runpath</code></h3><p>如果你可以重新编译程序，或者有权修改其可执行文件，你可以指定 <code>rpath</code> 或 <code>runpath</code>，这会将库文件路径嵌入到可执行文件中，从而在运行时自动找到库文件。</p>
<h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><p>在编译时使用 <code>-Wl,-rpath</code> 选项可以指定库文件的路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o your_program your_program.c -Wl,-rpath,/custom/lib -lyourlib</span><br></pre></td></tr></table></figure>

<p>这样程序会在运行时自动从 <code>/custom/lib</code> 中查找库文件。</p>
<h3 id="6-创建或修改配置文件-etc-ld-so-conf-或-etc-ld-so-conf-d"><a href="#6-创建或修改配置文件-etc-ld-so-conf-或-etc-ld-so-conf-d" class="headerlink" title="6. 创建或修改配置文件 /etc/ld.so.conf 或 /etc/ld.so.conf.d/"></a>6. 创建或修改配置文件 <code>/etc/ld.so.conf</code> 或 <code>/etc/ld.so.conf.d/</code></h3><p>你可以将自定义的库路径添加到系统的动态链接器配置中：</p>
<ol>
<li>编辑 <code>/etc/ld.so.conf</code> 或创建一个文件放入 <code>/etc/ld.so.conf.d/</code>，并添加自定义库的路径。</li>
<li>运行 <code>ldconfig</code> 命令更新链接器的缓存。</li>
</ol>
<h4 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/custom/lib&quot;</span> &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>

<p>这样系统会自动从 <code>/custom/lib</code> 路径中查找库文件。</p>
<hr>
<p>通过这些方法，可以在 Linux 系统中灵活地指定程序运行时所链接的库文件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/242024/07/23/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8Cloudflare%E5%81%9A%E7%BD%91%E7%AB%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/242024/07/23/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8Cloudflare%E5%81%9A%E7%BD%91%E7%AB%99/" class="post-title-link" itemprop="url">树莓派使用Cloudflare做网站</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：242024-07-23 15:08:00" itemprop="dateCreated datePublished" datetime="242024-07-23T15:08:00+08:00">242024-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-23 15:09:12" itemprop="dateModified" datetime="2024-07-23T15:09:12+08:00">2024-07-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果想用树莓派之类的设备去做网站，方法一是需要想办法弄到一个公网 IP，无论是直接从运营商要，还是在阿里云、腾讯云上做 frps 之类的内网穿透，都挺麻烦的；方法二是如果有 IPv6，那么就去做 v6only 的解析，并且这个 IPv6 的地址还可能会经常变，这样就会使得网站可用性变得非常差，并且 v4 用户就惨了。</p>
<p>现今，Cloudflare Argo Tunnel 已经免费开放啦。这个东西有什么用呢？简单的来说就是在任何可以访问 cloudflare 的机器和 cloudflare 中搭建一个安全的加密隧道，然后这个隧道可以用来承载很多不同种类型的流量，比如说 http（会被自动换成 https），tcp，ssh，smb，rdp，甚至是 unix 套接字都可以哦。</p>
<p>也就是说，只要你在家里的机器上一顿操作，那么你家里的机器就可以通过 cloudflare 的网络来达到全球可以访问的目的了。听起来是不是很棒！</p>
<p>总结下来这样做大概有这几步：</p>
<ol>
<li>注册 cloudflare 账号</li>
<li>（可选）把域名的 ns 改成 cloudflare</li>
<li>安装 cloudflared 并登录</li>
<li>创建 argo tunnel</li>
<li>创建 dns 记录</li>
<li>配置 tunnel</li>
<li>运行</li>
</ol>
<p>本文以 Raspberry Pi 3 + Ubuntu 20.04 为例</p>
<h2 id="注册-cloudflare-账号"><a href="#注册-cloudflare-账号" class="headerlink" title="注册 cloudflare 账号"></a>注册 cloudflare 账号</h2><h2 id="把域名的-ns-改成-cloudflare"><a href="#把域名的-ns-改成-cloudflare" class="headerlink" title="把域名的 ns 改成 cloudflare"></a>把域名的 ns 改成 cloudflare</h2><p>这一步是可选的，Argo Tunnel 会提供一个默认的域名，当然如果能用自己的域名就更好啦。</p>
<h2 id="安装-cloudflared-并登录"><a href="#安装-cloudflared-并登录" class="headerlink" title="安装 cloudflared 并登录"></a>安装 cloudflared 并登录</h2><p>具体的话，可以参考<a target="_blank" rel="noopener" href="https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup">这篇官方文档</a>。我的树莓派是 aarch64 的架构，也就是 arm64.</p>
<ol>
<li>wget -O cloudflared <a target="_blank" rel="noopener" href="https://github.com/cloudflare/cloudflared/releases/download/2021.4.0/cloudflared-linux-arm64">https://github.com/cloudflare/cloudflared/releases/download/2021.4.0/cloudflared-linux-arm64</a></li>
<li>chmod +x cloudflared</li>
<li>sudo cp cloudflared &#x2F;usr&#x2F;loca&#x2F;bin&#x2F;</li>
</ol>
<p>然后就可以开始登录啦！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloudflared tunnel login</span><br></pre></td></tr></table></figure>

<p>然后再打开的页面中选择你的域名～Pi 那边大概会有如下输出：</p>
<blockquote>
<p>You have successfully logged in.</p>
<p>If you wish to copy your credentials to a server, they have been saved to:</p>
<p>&#x2F;home&#x2F;benny&#x2F;.cloudflared&#x2F;cert.pem</p>
</blockquote>
<h2 id="创建-argo-tunnel"><a href="#创建-argo-tunnel" class="headerlink" title="创建 argo tunnel"></a>创建 argo tunnel</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloudflared tunnel create &lt;NAME&gt;</span><br></pre></td></tr></table></figure>

<p>这条命令会输出一个 tunnle UUID</p>
<p>name 可以自己随便取一个，比如说 Pi 啦～Yui 啦～随便的啦</p>
<p>想要查看 tunnel 列表，可以使用 <code>cloudflared tunnel list</code></p>
<p>很明显，想要删除，那就 delete 啦 <code>cloudflared tunnel delete pi</code></p>
<h2 id="创建-DNS-记录"><a href="#创建-DNS-记录" class="headerlink" title="创建 DNS 记录"></a>创建 DNS 记录</h2><p>有两种办法，一种是去 cloudflare dashboard 中创建一条道<code>id. cfargotunnel.com</code>的 CNAME 解析，另外一种是使用 cli 命令～</p>
<p>那比如说我要创建一个 abcd.dmesg.app，那么就可以这样做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloudflared tunnel route dns &lt;UUID or NAME&gt; abcd.dmesg.com</span><br></pre></td></tr></table></figure>

<p>或者在网页上这样添加，结果是一样滴<br><img src="https://isrootblog-1251140236.cos.ap-beijing.myqcloud.com/uPic/202310271435262.png" alt="image.png"></p>
<p>此时如果你访问 abcd.dmesg.app，会看到 1033 错误的哦，因为我们的 tunnel 还没有运行。</p>
<h2 id="配置-tunnel"><a href="#配置-tunnel" class="headerlink" title="配置 tunnel"></a>配置 tunnel</h2><p>那么接下来就需要在树莓派上配置如何 tunnel 了，一个最简单的例子是这样的：</p>
<ol>
<li>tunnel: pi</li>
<li>credentials-file: &#x2F;home&#x2F;benny&#x2F;.cloudflared&#x2F;af4d19d0-7fb1-40ea-88b7-97036c026ca4.json</li>
<li>ingress:</li>
<li>- hostname: pi.dmesg.app</li>
<li><pre><code> service: http://localhost:8000
</code></pre>
</li>
<li>- service: http_status:404</li>
</ol>
<p>其中 hostname 就是上面的那个域名，service 表示我们要承载什么流量，如果想要承载 ssh，那么就<code>service: ssh://localhost:22</code>就好了。</p>
<p>最开始的 uuid 同样可以替换成 tunnel name</p>
<p>然后我们……</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloudflared tunnel --config ~/tunnel.yml run</span><br></pre></td></tr></table></figure>

<p>如果不想写这种配置文件，那么可以一条 cli 解决</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cloudflared tunnel run --url localhost:8000 &lt;NAME or UUID&gt;</span><br></pre></td></tr></table></figure>

<p>看到一大串输出，没有报错，那我们的 tunnel 就成功了。当然树莓派上 8000 还没有程序在监听，那我们再赶紧开一个吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 127.0.0.1:8000:80 nginx:alpine</span><br></pre></td></tr></table></figure>

<p>这个时候打开浏览器刷新一下，你的页面就已经出来啦！<br><img src="https://isrootblog-1251140236.cos.ap-beijing.myqcloud.com/uPic/202310271436117.png" alt="image.png"></p>
<h3 id="以服务模式运行"><a href="#以服务模式运行" class="headerlink" title="以服务模式运行"></a>以服务模式运行</h3><p>当然了，咱不能开个 screen 去运行 argo tunnel 啊……</p>
<p>那么执行这条命令来安装服务</p>
<ol>
<li># 需要有～&#x2F;.cloudflared&#x2F;config.yaml</li>
<li>sudo cloudflared service install</li>
<li># 指定配置文件位置</li>
<li>cloudflared --config CONFIG-FILE service install</li>
</ol>
<p>这个时候哪怕重启都不怕啦😨</p>
<p>原网址: <a target="_blank" rel="noopener" href="https://dmesg.app/argo-tunnel.html">访问</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/2025/12/09/Decorator%20%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/12/09/Decorator%20%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-12-09 18:19:07" itemprop="dateCreated datePublished" datetime="2025-12-09T18:19:07+08:00">2025-12-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h1><ul>
<li>在某些情况下我们可能会”过度的使用继承来扩展对象功能”，由于继承为类型引入的<strong>静态</strong>特质，使得这种拓展方式缺乏<strong>灵活性</strong>，并且随着<strong>子类</strong>的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀.</li>
<li>如何使”对象功能的扩展”能够根据需求动态的来实现？同时避免”扩展功能的增多”带来子类膨胀问题？从而使得任何”功能扩展变化”所导致的影响将为最低？</li>
</ul>
<h1 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h1><p>动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 &amp; 减少子类个数）。 ——《设计模式》GoF</p>
<p>Decorator属于”单一职责”模式：在软件组织的设计中，如果责任划分得不清晰，使用继承得到的结果往往是随着需求变化的，子类急剧膨胀，同时充斥着重复代码，这时候的关键是划清责任。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2025/12/09/Decorator%20%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">吴晓宁</p>
  <div class="site-description" itemprop="description">记录一些自己的见闻</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴晓宁</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
