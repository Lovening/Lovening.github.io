<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.isroots.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="C++：位操作基础篇之位操作全面总结位操作篇共分为基础篇和提高篇。在计算机中所有数据都是以二进制的形式储存的。位运算其实就是直接对在内存中的二进制数据进行操作，因此处理数据的速度非常快。在实际编程中，如果能巧妙运用位操作，完全可以达到四两拨千斤的效果，正因为位操作的这些优点，所以位操作在各大IT公司的笔试面试中一直是个热点问题。因此本文将对位操作进行如下方面总结：– 一． 位操作基础，用一张表描述">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 位操作总结">
<meta property="og:url" content="https://blog.isroots.com/242024/09/02/C++%20%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="吴晓宁blog">
<meta property="og:description" content="C++：位操作基础篇之位操作全面总结位操作篇共分为基础篇和提高篇。在计算机中所有数据都是以二进制的形式储存的。位运算其实就是直接对在内存中的二进制数据进行操作，因此处理数据的速度非常快。在实际编程中，如果能巧妙运用位操作，完全可以达到四两拨千斤的效果，正因为位操作的这些优点，所以位操作在各大IT公司的笔试面试中一直是个热点问题。因此本文将对位操作进行如下方面总结：– 一． 位操作基础，用一张表描述">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="+242024-09-02T11:43:00.000Z">
<meta property="article:modified_time" content="2024-09-02T11:44:15.461Z">
<meta property="article:author" content="吴晓宁">
<meta property="article:tag" content="blog,编程">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.isroots.com/242024/09/02/C++%20%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++ 位操作总结 | 吴晓宁blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">吴晓宁blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">吴晓宁blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.isroots.com/242024/09/02/C++%20%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="吴晓宁">
      <meta itemprop="description" content="记录一些自己的见闻">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吴晓宁blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ 位操作总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：242024-09-02 19:43:00" itemprop="dateCreated datePublished" datetime="242024-09-02T19:43:00+08:00">242024-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-02 19:44:15" itemprop="dateModified" datetime="2024-09-02T19:44:15+08:00">2024-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>C++：位操作基础篇之位操作全面总结位操作篇共分为基础篇和提高篇。<br>在计算机中所有数据都是以二进制的形式储存的。位运算其实就是直接对在内存中的二进制数据进行操作，因此处理数据的速度非常快。在实际编程中，如果能巧妙运用位操作，完全可以达到四两拨千斤的效果，正因为位操作的这些优点，所以位操作在各大IT公司的笔试面试中一直是个热点问题。因此本文将对位操作进行如下方面总结：<br>– 一． 位操作基础，用一张表描述位操作符的应用规则并详细解释。<br>– 二． 常用位操作小技巧，有判断奇偶、交换两数、变换符号、求绝对值。<br>– 三． 位操作与空间压缩，针对筛素数进行空间压缩。<br>– 四． 位操作的趣味应用，列举了位操作在高低位交换、二进制逆序、二进制中1的个数以及缺失的数字这4种趣味应用。</p>
<h2 id="一-位操作基础"><a href="#一-位操作基础" class="headerlink" title="一 位操作基础"></a>一 位操作基础</h2><p>基本的位操作符有与、或、异或、取反、左移、右移这6种，它们的运算规则如下所示：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>与</td>
<td>两个位都位1，结果才为1</td>
</tr>
<tr>
<td></td>
<td></td>
<td>或 | 两个位都为0，结果才为0</td>
</tr>
<tr>
<td>^</td>
<td>异或</td>
<td>两个位相同为0，相异为1</td>
</tr>
<tr>
<td>~</td>
<td>取反</td>
<td>0变1,1变0</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>各二进位全部左移若干位，高位丢弃，低位补0</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</td>
</tr>
</tbody></table>
<p>注意以下几点：<br>– 1. 在这6种操作符，只有~取反是单目操作符，其它5种都是双目操作符。<br>– 2. 位操作只能用于整形数据，对float和double类型进行位操作会被编译器报错。<br>– 3. 对于移位操作，在微软的VC6.0和VS2008编译器都是采取算术称位即算术移位操作，算术移位是相对于逻辑移位，它们在右移操作中都一样，低位补0即可，但在左移中逻辑移位的高位补0而算术移位的高位是补符号位。如下面代码会输出-4和3。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a= <span class="number">-15</span>,b=<span class="number">15</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,a&gt;&gt;<span class="number">2</span>,b&gt;&gt;<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>因为15&#x3D;0000 1111(二进制)，右移二位，最高位由符号位填充将得到0000 0011即3。-15 &#x3D; 1111 0001(二进制)，右移二位，最高位由符号位填充将得到1111 1100即-4（见注1）。</p>
<ul>
<li><ol start="4">
<li>位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。比如要得到像1，3，5，9这些2^i+1的数字。写成 int a &#x3D; 1 &lt;&lt; i + 1;是不对的，程序会先执行i + 1，再执行左移操作。应该写成int a &#x3D; (1 &lt;&lt; i) + 1;</li>
</ol>
</li>
<li><ol start="5">
<li>另外位操作还有一些复合操作符，如&amp;&#x3D;、|&#x3D;、 ^&#x3D;、&lt;&lt;&#x3D;、&gt;&gt;&#x3D;。</li>
</ol>
</li>
</ul>
<h2 id="二-常用位操作小技巧"><a href="#二-常用位操作小技巧" class="headerlink" title="二 常用位操作小技巧"></a>二 常用位操作小技巧</h2><ul>
<li>1.判断奇偶<br>  只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if (a &amp; 1 &#x3D;&#x3D; 0)代替if (a % 2 &#x3D;&#x3D; 0)来判断a是不是偶数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(int i = 0;i&lt;100;++i)</span><br><span class="line">    if(i&amp;1)</span><br><span class="line">        printf(&quot;%d&quot;,i);</span><br><span class="line">putchar(&#x27;\n&#x27;);</span><br></pre></td></tr></table></figure>

<ul>
<li>2.交换两个数<br>  一般的写法为:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void swap(int &amp;a,int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a!=b)</span><br><span class="line">    &#123;</span><br><span class="line">    int c=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用位操作来实现两个数交换而不使用第三个数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void swap(int &amp;a,int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    if(a != b)</span><br><span class="line">    &#123;</span><br><span class="line">    a ^= b;</span><br><span class="line">    b ^= a;</span><br><span class="line">    a ^= b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一步 a^&#x3D;b 即a&#x3D;(a^b);<br>第二步 b^&#x3D;a 即b&#x3D;b^(a^b)，由于^运算满足交换律，b^(a^b)&#x3D;b^b^a。由于一个数和自己异或的结果为0并且任何数与0异或都会不变的，所以此时b被赋上了a的值。<br>第三步 a^&#x3D;b 就是a&#x3D;a^b，由于前面二步可知a&#x3D;(a^b)，b&#x3D;a，所以a&#x3D;a^b即a&#x3D;(a^b)^a。故a会被赋上b的值。<br>再来个实例说明下以加深印象。int a &#x3D; 13, b &#x3D; 6;<br>a的二进制为 13&#x3D;8+4+1&#x3D;1101(二进制)<br>b的二进制为 6&#x3D;4+2&#x3D;110(二进制)<br>第一步 a^&#x3D;b a &#x3D; 1101 ^ 110 &#x3D; 1011;<br>第二步 b^&#x3D;a b &#x3D; 110 ^ 1011 &#x3D; 1101;即b&#x3D;13<br>第三步 a^&#x3D;b a &#x3D; 1011 ^ 1101 &#x3D; 110;即a&#x3D;5<br>– 3.变换符号<br>变换符号就是正数变成负数，负数变成正数。<br>如对于-11和11，可以通过下面的变换方法将-11变成11<br>1111 0101(二进制) –取反-&gt; 0000 1010(二进制) –加1-&gt; 0000 1011(二进制)<br>同样可以这样的将11变成-11<br>0000 1011(二进制) –取反-&gt; 0000 1010(二进制) –加1-&gt; 1111 0101(二进制)<br>因此变换符号只需要取反后加1即可。完整代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int SignReversal(int a)</span><br><span class="line">&#123;</span><br><span class="line">   return ~a + 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;对整数变换符号 \n\n&quot;);</span><br><span class="line">    int a = 7, b = -12345;</span><br><span class="line">    printf(&quot;%d  %d\n&quot;, SignReversal(a), SignReversal(b));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4.求绝对值<br>  位操作也可以用来求绝对值，对于负数可以通过对其取反后加1来得到正数。对-6可以这样：<br>  1111 1010(二进制) –取反-&gt;0000 0101(二进制) -加1-&gt; 0000 0110(二进制)<br>  来得到6。<br>  因此先移位来取符号位，int i &#x3D; a &gt;&gt; 31;要注意如果a为正数，i等于0，为负数，i等于-1。然后对i进行判断——如果i等于0，直接返回。否之，返回~a+1。完整代码如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int abs(int a)</span><br><span class="line">&#123;</span><br><span class="line">    int i = a&gt;&gt;31;</span><br><span class="line">    return i == 0 ? a:(~a+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在再分析下。对于任何数，与0异或都会保持不变，与-1即0xFFFFFFFF异或就相当于取反。因此，a与i异或后再减i（因为i为0或-1，所以减i即是要么加0要么加1）也可以得到绝对值。所以可以对上面代码优化下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int my_abs(int a)</span><br><span class="line">&#123;</span><br><span class="line">    int i = a &gt;&gt; 31;</span><br><span class="line">    return ((a ^ i) - i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三-位操作与空间压缩"><a href="#三-位操作与空间压缩" class="headerlink" title="三.位操作与空间压缩"></a>三.位操作与空间压缩</h2><p>素数法在这里不就详细介绍了，本文着重对筛素数法所使用的素数表进行优化来减小其空间占用。要压缩素数表的空间占用，可以使用位操作。下面是用筛素数法计算100以内的素数示例代码（注2）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;memory.h&gt;</span><br><span class="line">const int MAXN = 100;</span><br><span class="line">bool flag[MAXN];</span><br><span class="line">int primes[MAXN / 3], pi;</span><br><span class="line">//对每个素数，它的倍数必定不是素数。</span><br><span class="line">//有很多重复如flag[10]会在访问flag[2]和flag[5]时各访问一次</span><br><span class="line">void GetPrime_1()</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    pi = 0;</span><br><span class="line">    memset(flag, false, sizeof(flag));</span><br><span class="line">    for (i = 2; i &lt; MAXN; i++)</span><br><span class="line">        if (!flag[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[pi++] = i;</span><br><span class="line">            for (j = i; j &lt; MAXN; j += i)</span><br><span class="line">                flag[j] = true;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">void PrintfArray()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; pi; i++)</span><br><span class="line">        printf(&quot;%d &quot;, primes[i]);</span><br><span class="line">    putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;用筛素数法求100以内的素数\n&quot;);</span><br><span class="line">    GetPrime_1();</span><br><span class="line">    PrintfArray();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面程序是用bool数组来作标记的，bool型数据占1个字节（8位），因此用位操作来压缩下空间占用将会使空间的占用减少八分之一。<br>下面考虑下如何在数组中对指定位置置1，先考虑如何对一个整数在指定位置上置1。对于一个整数可以通过将1向左移位后与其相或来达到在指定位上置1的效果，代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在一个数指定位上置1</span><br><span class="line">int j = 0;</span><br><span class="line">j |=  1 &lt;&lt; 10;</span><br><span class="line">printf(&quot;%d\n&quot;, j);</span><br></pre></td></tr></table></figure>

<p>同样，可以1向左移位后与原数相与来判断指定位上是0还是1（也可以将原数右移若干位再与1相与）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//判断指定位上是0还是1</span><br><span class="line">int j = 1 &lt;&lt; 10;</span><br><span class="line">if ((j &amp; (1 &lt;&lt; 10)) != 0)</span><br><span class="line">    printf(&quot;指定位上为1&quot;);</span><br><span class="line">else</span><br><span class="line">    printf(&quot;指定位上为0&quot;);</span><br></pre></td></tr></table></figure>

<p>扩展到数组上，我们可以采用这种方法，因为数组在内存上也是连续分配的一段空间，完全可以“认为”是一个很长的整数。先写一份测试代码，看看如何在数组中使用位操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;     对数组中指定位置上置位和判断该位\n&quot;);</span><br><span class="line">    //在数组中在指定的位置上写1</span><br><span class="line">    int b[5] = &#123;0&#125;;</span><br><span class="line">    int i;</span><br><span class="line">    //在第i个位置上写1</span><br><span class="line">    for (i = 0; i &lt; 40; i += 3)</span><br><span class="line">        b[i / 32] |= (1 &lt;&lt; (i % 32));</span><br><span class="line">    //输出整个bitset</span><br><span class="line">    for (i = 0; i &lt; 40; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((b[i / 32] &gt;&gt; (i % 32)) &amp; 1)</span><br><span class="line">            putchar(&#x27;1&#x27;);</span><br><span class="line">        else</span><br><span class="line">            putchar(&#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    putchar(&#x27;\n&#x27;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将上面筛素数方法改成使用位操作压缩后的筛素数方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;memory.h&gt;</span><br><span class="line">const int MAXN = 100;</span><br><span class="line">int flag[MAXN / 32];</span><br><span class="line">int primes[MAXN / 3], pi;</span><br><span class="line">void GetPrime_1()</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    pi = 0;</span><br><span class="line">    memset(flag, 0, sizeof(flag));</span><br><span class="line">    for (i = 2; i &lt; MAXN; i++)</span><br><span class="line">        if (!((flag[i / 32] &gt;&gt; (i % 32)) &amp; 1))</span><br><span class="line">        &#123;</span><br><span class="line">            primes[pi++] = i;</span><br><span class="line">            for (j = i; j &lt; MAXN; j += i)</span><br><span class="line">                flag[j / 32] |= (1 &lt;&lt; (j % 32));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">void PrintfArray()</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; pi; i++)</span><br><span class="line">        printf(&quot;%d &quot;, primes[i]);</span><br><span class="line">    putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;用位操作压缩后筛素数法求100以内的素数\n&quot;);</span><br><span class="line">    GetPrime_1();</span><br><span class="line">    PrintfArray();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四-位操作趣味应用"><a href="#四-位操作趣味应用" class="headerlink" title="四 位操作趣味应用"></a>四 位操作趣味应用</h2><ul>
<li>1． 高低位交换<br>  给出一个16位的无符号整数。称这个二进制数的前8位为“高位”，后8位为“低位”。现在写一程序将它的高低位交换。例如，数34520用二进制表示为：<br>  10000110 11011000<br>  将它的高低位进行交换，我们得到了一个新的二进制数：<br>  11011000 10000110<br>  它即是十进制的55430。<br>  这个问题用位操作解决起来非常方便，设x&#x3D;34520&#x3D;10000110 11011000(二进制) 由于x为无符号数，右移时会执行逻辑右移即高位补0，因此x右移8位将得到0000000010000110。而x左移8位将得到11011000 00000000。可以发现只要将x&gt;&gt;8与x&lt;&lt;8这两个数相与就可以得到11011000 10000110。用代码实现非常简洁：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void PrintfBinary(T a)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = sizeof(a) * 8 - 1; i &gt;= 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((a &gt;&gt; i) &amp; 1)</span><br><span class="line">            putchar(&#x27;1&#x27;);</span><br><span class="line">        else</span><br><span class="line">            putchar(&#x27;0&#x27;);</span><br><span class="line">        if (i == 8)</span><br><span class="line">            putchar(&#x27; &#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;高低位交换 \n&quot;);</span><br><span class="line">    printf(&quot;交换前:    &quot;);</span><br><span class="line">    unsigned short a = 3344520;</span><br><span class="line">    PrintfBinary(a);</span><br><span class="line">    printf(&quot;交换后:    &quot;);</span><br><span class="line">    a = (a &gt;&gt; 8) | (a &lt;&lt; 8);</span><br><span class="line">    PrintfBinary(a);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>2.二进制逆序<br>  我们知道如何对字符串求逆序，现在要求计算二进制的逆序，如数34520用二进制表示为：<br>  10000110 11011000<br>  将它逆序，我们得到了一个新的二进制数：<br>  00011011 01100001<br>  它即是十进制的7009。<br>  回顾下字符串的逆序，可以从字符串的首尾开始，依次交换两端的数据。在二进制逆序我们也可以用这种方法，但运用位操作的高低位交换来处理二进制逆序将会得到更简洁的方法。类似于归并排序的分组处理，可以通过下面4步得到16位数据的二进制逆序：<br>  第一步：每2位为一组，组内高低位交换<br>  10 00 01 10 11 01 10 00<br>  –&gt;01 00 10 01 11 10 01 00<br>  第二步：每4位为一组，组内高低位交换<br>  0100 1001 1110 0100<br>  –&gt;0001 0110 1011 0001<br>  第三步：每8位为一组，组内高低位交换<br>  00010110 10110001<br>  –&gt;01100001 00011011<br>  第四步：每16位为一组，组内高低位交换<br>  01100001 00011011<br>  –&gt;00011011 01100001<br>  对第一步，可以依次取出每2位作一组，再组内高低位交换，这样有点麻烦，下面介绍一种非常有技巧的方法。先分别取10000110 11011000的奇数位和偶数位，空位以下划线表示。<br>  原 数 10000110 11011000<br>  奇数位 1_0_0_1_ 1_0_1_0_<br>  偶数位 _0_0_1_0 _1_1_0_0<br>  将下划线用0填充，可得<br>  原 数 10000110 11011000<br>  奇数位 10000010 10001000<br>  偶数位 00000100 01010000<br>  再将奇数位右移一位，偶数位左移一位，此时将这两个数据相与即可以达到奇偶位上数据交换的效果了。<br>  原 数 10000110 11011000<br>  奇数位右移 01000011 01101100<br>  偶数位左移 0000100 010100000<br>  相与得到 01001000 11100100<br>  可以看出，结果完全达到了奇偶位的数据交换，再来考虑代码的实现——<br>  取x的奇数位并将偶数位用0填充用代码实现就是x &amp; 0xAAAA<br>  取x的偶数位并将奇数位用0填充用代码实现就是x &amp; 0x5555<br>  因此，第一步就用代码实现就是：<br>  x &#x3D; ((x &amp; 0xAAAA) &gt;&gt; 1) | ((x &amp; 0x5555) &lt;&lt; 1);</li>
</ul>
<p>完整代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void PrintfBinary(T a)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = sizeof(a) * 8 - 1; i &gt;= 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((a &gt;&gt; i) &amp; 1)</span><br><span class="line">            putchar(&#x27;1&#x27;);</span><br><span class="line">        else</span><br><span class="line">            putchar(&#x27;0&#x27;);</span><br><span class="line">        if (i == 8)</span><br><span class="line">            putchar(&#x27; &#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;二进制逆序 \n&quot;);</span><br><span class="line">    printf(&quot;逆序前:    &quot;);</span><br><span class="line">    unsigned short a = 34520;</span><br><span class="line">    PrintfBinary(a);</span><br><span class="line">    printf(&quot;逆序后:    &quot;);</span><br><span class="line">    a = ((a &amp; 0xAAAA) &gt;&gt; 1) | ((a &amp; 0x5555) &lt;&lt; 1);</span><br><span class="line">    a = ((a &amp; 0xCCCC) &gt;&gt; 2) | ((a &amp; 0x3333) &lt;&lt; 2);</span><br><span class="line">    a = ((a &amp; 0xF0F0) &gt;&gt; 4) | ((a &amp; 0x0F0F) &lt;&lt; 4);</span><br><span class="line">    a = ((a &amp; 0xFF00) &gt;&gt; 8) | ((a &amp; 0x00FF) &lt;&lt; 8);</span><br><span class="line">    PrintfBinary(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>3.二进制中的个数<br>  统计二进制中1的个数可以直接移位再判断，当然像《编程之美》书中用循环移位计数或先打一个表再计算都可以。本文详细讲解一种高效的方法。以34520为例，可以通过下面四步来计算其二进制中1的个数二进制中1的个数。<br>  第一步：每2位为一组，组内高低位相加<br>  10 00 01 10 11 01 10 00<br>  –&gt;01 00 01 01 10 01 01 00<br>  第二步：每4位为一组，组内高低位相加<br>  0100 0101 1001 0100<br>  –&gt;0001 0010 0011 0001<br>  第三步：每8位为一组，组内高低位相加<br>  00010010 00110001<br>  –&gt;00000011 00000100<br>  第四步：每16位为一组，组内高低位相加<br>  00000011 00000100<br>  –&gt;00000000 00000111<br>  这样最后得到的00000000 00000111即7即34520二进制中1的个数。类似上文中对二进制逆序的做法不难实现第一步的代码：<br>  x &#x3D; ((x &amp; 0xAAAA) &gt;&gt; 1) + (x &amp; 0x5555);</li>
</ul>
<p>完整代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">template &lt;class T&gt;</span><br><span class="line">void PrintfBinary(T a)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = sizeof(a) * 8 - 1; i &gt;= 0; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((a &gt;&gt; i) &amp; 1)</span><br><span class="line">            putchar(&#x27;1&#x27;);</span><br><span class="line">        else</span><br><span class="line">            putchar(&#x27;0&#x27;);</span><br><span class="line">        if (i == 8)</span><br><span class="line">            putchar(&#x27; &#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    putchar(&#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;二进制中1的个数\n&quot;);</span><br><span class="line">    unsigned short a = 34520;</span><br><span class="line">    printf(&quot;原数    %6d的二进制为:  &quot;, a);</span><br><span class="line">    PrintfBinary(a);</span><br><span class="line">    a = ((a &amp; 0xAAAA) &gt;&gt; 1) + (a &amp; 0x5555);</span><br><span class="line">    a = ((a &amp; 0xCCCC) &gt;&gt; 2) + (a &amp; 0x3333);</span><br><span class="line">    a = ((a &amp; 0xF0F0) &gt;&gt; 4) + (a &amp; 0x0F0F);</span><br><span class="line">    a = ((a &amp; 0xFF00) &gt;&gt; 8) + (a &amp; 0x00FF);</span><br><span class="line">    printf(&quot;计算结果%6d的二进制为:  &quot;, a);</span><br><span class="line">    PrintfBinary(a);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>4.将数据位某位置1 或者置 0</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define setbit(x,y) x|=(1&lt;&lt;y)         //将X的第Y位置1</span><br><span class="line">#define clrbit(x,y) x&amp;=~(1&lt;&lt;y)            //将X的第Y位清0</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">       unsigned short Nun = 0;</span><br><span class="line">       setbit(Nun,15);</span><br><span class="line">       setbit(Nun,14);</span><br><span class="line">       //clrbit(Nun,15);</span><br><span class="line">       if (Nun&gt;&gt;14&amp;1)   //判断第十四位是否为一</span><br><span class="line">       &#123;</span><br><span class="line">              cout&lt;&lt;&quot;14位为1&quot;&lt;&lt;endl;</span><br><span class="line">       &#125;</span><br><span class="line">       if (Nun&gt;&gt;15&amp;1)  //判断第十五位是否为一</span><br><span class="line">       &#123;</span><br><span class="line">              cout&lt;&lt;&quot;15位为1&quot;&lt;&lt;endl;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/242024/09/02/Qt%E4%B8%AD%E7%9A%84%20pro%20%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/" rel="prev" title="Qt中的 pro 文件介绍">
      <i class="fa fa-chevron-left"></i> Qt中的 pro 文件介绍
    </a></div>
      <div class="post-nav-item">
    <a href="/242024/09/02/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%B8%ADint%E8%BD%ACchar%20%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E9%97%AE%E9%A2%98/" rel="next" title="数据传输中int转char 大小端的问题">
      数据传输中int转char 大小端的问题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">一 位操作基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E5%B8%B8%E7%94%A8%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="nav-number">2.</span> <span class="nav-text">二 常用位操作小技巧</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E4%BD%8D%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%8E%8B%E7%BC%A9"><span class="nav-number">3.</span> <span class="nav-text">三.位操作与空间压缩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B-%E4%BD%8D%E6%93%8D%E4%BD%9C%E8%B6%A3%E5%91%B3%E5%BA%94%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">四 位操作趣味应用</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">吴晓宁</p>
  <div class="site-description" itemprop="description">记录一些自己的见闻</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">89</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">吴晓宁</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
